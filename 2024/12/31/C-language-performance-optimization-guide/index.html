<!DOCTYPE html>
<html lang="">
    <!-- title -->




<!-- keywords -->




<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="hurricane618">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="hurricane618">
    
    <meta name="keywords" content="hexo,web security,pwn,ctf,hurricane618,代码审计,iot">
    
    <meta name="description" content="hurricane618's blog">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>C语言性能优化指南 · 风之栖息地|hurricane618&#39;s blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/hurricane_favicon.ico">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
    <!-- <script>
        (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)          })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
        ga('create', 'UA-121933059-1', 'auto');
        ga('send', 'pageview');
     </script> -->
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-VW7DP47D51"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-VW7DP47D51');
    </script>
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/">风之栖息地</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">C语言性能优化指南</a>
            </div>
    </div>
    
    <a class="home-link" href="/">风之栖息地</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg1.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            C语言性能优化指南
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class="post-intro-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="总结">总结</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="性能">性能</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">10.5k</span>阅读时长: <span class="post-count reading-time">40 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2024/12/31</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在甲方待了一段时间发现，在企业中想要提升安全性或者落地某个新的安全能力，总是需要和业务性能进行对比。如果某个安全特性的性能开销过大，那么对于业务来讲是一种不可接受的代价。因此，安全从业者学习一点性能优化的手段也是非常重要的。这里博主主要在操作系统领域，相关的代码主要以C为主，所以性能优化也是围绕着语言相关特点。</p>
<p>C语言从代码到可执行文件，再到最终的运行阶段，主要是两个部分组成——编译阶段和执行阶段。针对编译阶段，我们能做的就是尽可能的利用编译器特性和特殊编码技法来优化；执行阶段涉及到指令的热点运行，由于程序执行的局部性原理，我们的大量代码在执行时往往会重复一小段逻辑。因此，性能优化的重点就是在于这些热点函数之中。对于非热点函数，我们则更加关注体积，怎么写能够使得代码编译出来的指令数最少，减少对空间的占用。</p>
<p>以下则从六种不同的角度，针对C语言程序做优化。</p>
<h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><p>对于非编译器开发的程序员来说，新增一个编译选项就能搞定的事情，肯定是非常之轻松的活。</p>
<h3 id="通用编译优化-O"><a href="#通用编译优化-O" class="headerlink" title="通用编译优化 -O"></a>通用编译优化 -O</h3><p>编译器一般会默认一个优化等级，但当我们想要朝着更优的方向前行时，就需要将优化等级调高。这里在编译Linux内核时，默认是-O2，其他平台类二进制需要关注项目本身的设置。如果觉得-O2的效果一般，可以尝试-O3。</p>
<h3 id="指令架构优化-march"><a href="#指令架构优化-march" class="headerlink" title="指令架构优化 -march"></a>指令架构优化 -march</h3><p>编译器针对不同的指令集以及cpu架构都有着极强的针对性优化（搞编译优化的人是真的顶），比如这里的<code>-march=x86-64-v3</code> 就是针对v3版本的x86-64指令集做专属优化。除了指令集还有cpu架构，比如经典的奔腾，haswell，还有i7等等。同理在ARM架构上也有类似的参数可控选择，根据不同的ARM指令集版本也有不同的参数。</p>
<p>更多细节可参考：</p>
<p>x86 <a href="https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html" target="_blank" rel="noopener">https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html</a></p>
<p>arm <a href="https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html" target="_blank" rel="noopener">https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html</a></p>
<h3 id="链接优化-flto"><a href="#链接优化-flto" class="headerlink" title="链接优化 -flto"></a>链接优化 -flto</h3><p>通过把很多编译优化放在链接阶段执行，实现范围更广的优化面。</p>
<p><code>-flto</code> 可以在编译时进行全局优化，但整体的时间开销和编译资源开销将大大增加，而 <code>-flto=thin</code> 是一种折衷方案，它在链接阶段进行优化，同时减少了编译时间和资源消耗。</p>
<p>链接优化的目标：</p>
<ul>
<li>内联函数：优化开启之前只能针对单一C源代码优化，开启后能针对全局整体做内联优化</li>
<li>函数重定位：能通过静态分析调整函数代码位置，减少函数调用链长度</li>
<li>代码融合：多个代码块合并，减少代码的执行次数</li>
<li>数据流分析，移除不必要的死代码</li>
</ul>
<p>总的来说，链接优化能在全局层面做到更好的优化方案，减少代码体积和增强程序性能。</p>
<h3 id="关闭安全选项（不推荐）"><a href="#关闭安全选项（不推荐）" class="headerlink" title="关闭安全选项（不推荐）"></a>关闭安全选项（不推荐）</h3><p>作为一个安全从业者，非常的不推荐关闭这些安全选项，反而推荐去开启一些额外的安全编译选项来增强安全能力。但是，在某些性能要求的特殊场景下，确实会关闭某些安全能力来提升性能。</p>
<p>以下列举一些关闭的方式，但还是要说，这是饮鸩止渴。</p>
<ul>
<li><code>-fno-sanitize=all</code> 关闭所有的消毒器</li>
<li><code>-fcf-protection=none</code> 关闭编译器自带的控制流保护</li>
<li><code>-fno-harden-compares</code> 关闭针对比较操作的防溢出处理</li>
<li><code>-fno-harden-conditional-branches</code> 关闭针对条件分支的安全增强</li>
<li><code>-fno-harden-control-flow-redundancy</code> 关闭控制流冗余检测的安全增强</li>
<li><code>-fno-hardened</code> 关闭一系列的安全增强选项</li>
<li><code>-fno-stack-protector</code> 关闭栈溢出保护机制</li>
<li><code>-fno-stack-check</code> 关闭栈的边界检查功能</li>
<li><code>-fno-stack-clash-protection</code> 关闭栈冲突保护</li>
<li><code>-fno-stack-limit</code> 关闭栈大小限制约束</li>
<li><code>-fno-split-stack</code> 关闭栈切割的安全增强</li>
<li><code>-fstrub=disable</code> 关闭编译器中的结构化控制流保护</li>
</ul>
<h2 id="编码优化"><a href="#编码优化" class="headerlink" title="编码优化"></a>编码优化</h2><p>以下给出的代码示例，均通过在线的编译器网站进行编译反汇编转换。</p>
<p>网址：<a href="https://godbolt.org/" target="_blank" rel="noopener">https://godbolt.org/</a></p>
<p>编译器：ARM64 gcc 7.3</p>
<h3 id="局部变量缓存"><a href="#局部变量缓存" class="headerlink" title="局部变量缓存"></a>局部变量缓存</h3><p><strong>缓存多次访问的全局变量</strong></p>
<p>当我们有多次访问全局变量的需求时，不要多次使用全局变量，而是把全局变量读出后放入局部变量中，之后的读写都对该局部变量进行，最后的结果数值写回全局变量中，这样能避免频繁的内存空间访问，直接使用栈上的寄存器值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0x1234</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max_loop = get_loop_size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_loop; i++) &#123;</span><br><span class="line">        sum += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里如果有反汇编，就能看到每次读<code>sum</code>时都需要访问一次程序中的全局数据段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">sum:</span><br><span class="line">        .word   4660</span><br><span class="line">func():</span><br><span class="line">        stp     x29, x30, [sp, -32]!</span><br><span class="line">        add     x29, sp, 0</span><br><span class="line">        bl      get_loop_size()</span><br><span class="line">        str     w0, [x29, 24]</span><br><span class="line">        str     wzr, [x29, 28]</span><br><span class="line">.L3:</span><br><span class="line">        ldr     w1, [x29, 28]</span><br><span class="line">        ldr     w0, [x29, 24]</span><br><span class="line">        cmp     w1, w0</span><br><span class="line">        bge     .L4</span><br><span class="line">        adrp    x0, sum</span><br><span class="line">        add     x0, x0, :lo12:sum</span><br><span class="line">        ldr     w0, [x0]</span><br><span class="line">        add     w1, w0, 1</span><br><span class="line">        adrp    x0, sum</span><br><span class="line">        add     x0, x0, :lo12:sum</span><br><span class="line">        str     w1, [x0]</span><br><span class="line">        ldr     w0, [x29, 28]</span><br><span class="line">        add     w0, w0, 1</span><br><span class="line">        str     w0, [x29, 28]</span><br><span class="line">        b       .L3</span><br><span class="line">.L4:</span><br><span class="line">        nop</span><br><span class="line">        ldp     x29, x30, [sp], 32</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>如果将其存放进局部变量中，那么我们的值将会通过栈上的数据存储，在完成数据修改后再写回全局变量，这样能减少无效的内存访问，优化程序整体的速度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0x1234</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max_loop = get_loop_size();</span><br><span class="line">    <span class="keyword">int</span> tmp_sum = sum; <span class="comment">// 新的局部变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_loop; i++) &#123;</span><br><span class="line">        tmp_sum += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = tmp_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化之后的反汇编结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">sum:</span><br><span class="line">        .word   4660</span><br><span class="line">func():</span><br><span class="line">        stp     x29, x30, [sp, -32]!</span><br><span class="line">        add     x29, sp, 0</span><br><span class="line">        bl      get_loop_size()</span><br><span class="line">        str     w0, [x29, 20]</span><br><span class="line">        adrp    x0, sum</span><br><span class="line">        add     x0, x0, :lo12:sum</span><br><span class="line">        ldr     w0, [x0]</span><br><span class="line">        str     w0, [x29, 28]</span><br><span class="line">        str     wzr, [x29, 24]</span><br><span class="line">.L3:</span><br><span class="line">        ldr     w1, [x29, 24]</span><br><span class="line">        ldr     w0, [x29, 20]</span><br><span class="line">        cmp     w1, w0</span><br><span class="line">        bge     .L2</span><br><span class="line">        ldr     w0, [x29, 28]</span><br><span class="line">        add     w0, w0, 1</span><br><span class="line">        str     w0, [x29, 28]</span><br><span class="line">        ldr     w0, [x29, 24]</span><br><span class="line">        add     w0, w0, 1</span><br><span class="line">        str     w0, [x29, 24]</span><br><span class="line">        b       .L3</span><br><span class="line">.L2:</span><br><span class="line">        adrp    x0, sum</span><br><span class="line">        add     x0, x0, :lo12:sum</span><br><span class="line">        ldr     w1, [x29, 28]</span><br><span class="line">        str     w1, [x0]</span><br><span class="line">        nop</span><br><span class="line">        ldp     x29, x30, [sp], 32</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p><strong>缓存多次使用的表达式</strong></p>
<p>非常显而易见的事情，如果在编码中出现了多次的表达式，就应该用局部变量缓存一下，而不是用相同的语句再计算一遍。下面给了一个例子，我们在做计算的过程中，类似于<code>value_1</code> 和  <code>value_2</code>这样的表达式结果，如果后续还有使用的场景，在不影响最终结果的情况下就应该直接复用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value_1 = a + get_some_value();</span><br><span class="line">    <span class="keyword">int</span> value_2 = b + get_other_value();</span><br><span class="line">    do_something(value_1, value_2);</span><br><span class="line">    <span class="keyword">int</span> value_3 = a + b + get_some_value() + get_other_value();</span><br><span class="line">    <span class="keyword">return</span> value_3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码可以优化为下面的样子，当然这个地方编译器估计也能有点优化，但能优化到什么程度全看用的什么编译器，以及编译器的版本和编译选项。所以，这种能依靠编码优化的情况，尽量在代码实现时就完成最优处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value_1 = a + get_some_value();</span><br><span class="line">    <span class="keyword">int</span> value_2 = b + get_other_value();</span><br><span class="line">    do_something(value_1, value_2);</span><br><span class="line">    <span class="keyword">int</span> value_3 = value_1 + value_2;</span><br><span class="line">    <span class="keyword">return</span> value_3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="标记条件分支"><a href="#标记条件分支" class="headerlink" title="标记条件分支"></a>标记条件分支</h3><p><strong>__builtin_expect</strong></p>
<p>这个编译器内置的函数，能够标记最有可能进入的条件分支，而这个最常进入的条件分支的语句指令会被放在前面，不常进入的语句指令将会被放在后面，如此一来，可以最大化的发挥CPU的指令预取能力。<code>__builtin_expect</code>在很多时候也会被封装成<code>LIKELY</code>和<code>UNLIKELY</code>的宏，需要根据你所在的编码环境具体选择。（<strong>需要添加-O2的编译选项才能触发标记条件分支的优化</strong>）</p>
<p>具体用法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIKELY(x) __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNLIKELY(x) __builtin_expect(!!(x), 0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (LIKELY(a &gt; <span class="number">5</span>)) &#123;</span><br><span class="line">    a -= <span class="number">5</span>;</span><br><span class="line">    b++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    a += <span class="number">5</span>;</span><br><span class="line">    b--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (UNLIKELY(a &gt; <span class="number">5</span>)) &#123;</span><br><span class="line">    a -= <span class="number">5</span>;</span><br><span class="line">    b++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    a += <span class="number">5</span>;</span><br><span class="line">    b--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别编译以上两段不同的程序，我们通过反汇编就可以查看到，当条件语句为<code>LIKELY(a &gt; 5)</code>时，上面的<code>a -= 5;b++;</code>是在比较指令cmp的后面；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        cmp     w0, 5</span><br><span class="line">        ble     .L2</span><br><span class="line">        add     w1, w1, 1</span><br><span class="line">        sub     w0, w0, #5</span><br><span class="line">        add     w0, w0, w1</span><br><span class="line">        ret</span><br><span class="line">.L2:</span><br><span class="line">        sub     w1, w1, #1</span><br><span class="line">        add     w0, w0, 5</span><br><span class="line">        add     w0, w0, w1</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>当条件语句为<code>UNLIKELY(a &gt; 5)</code>时，下面的<code>a += 5;b--;</code>就会被放在指令cmp的后面。这样的结果，也对应了代码局部性原理，让更可能执行的指令放在一起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        cmp     w0, 5</span><br><span class="line">        bgt     .L5</span><br><span class="line">        sub     w1, w1, #1</span><br><span class="line">        add     w0, w0, 5</span><br><span class="line">        add     w0, w0, w1</span><br><span class="line">        ret</span><br><span class="line">.L5:</span><br><span class="line">        add     w1, w1, 1</span><br><span class="line">        sub     w0, w0, #5</span><br><span class="line">        add     w0, w0, w1</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p><strong>__builtin_unreachable</strong></p>
<p>同样为编译器内置的函数，能够标记分支中明确不可达的部分，这样能让编译器感知到该分支永远不可达。（那么永远不可达的代码为啥还要写呢？这又是另外一个问题了，某些场景是为了程序员方便理解，某些场景是为了清除编译告警等问题）针对这类标记，编译器在感知到不可达信息之后，能够使用更加激进的优化方案处理这段代码的指令翻译。</p>
<p>具体用法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">noreturn <span class="title">arm64_serror_panic</span><span class="params">(struct pt_regs *regs, <span class="keyword">unsigned</span> <span class="keyword">long</span> esr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    cpu_loop(); <span class="comment">// 永远不会退出的循环</span></span><br><span class="line">    unreachable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我这里直接拿了一段Linux内核的代码来举例子，这里有个场景是陷入循环中，永远不会退出。在这种场景下，末尾跟随一个<code>unreachable</code>表达后面永远不会到达。这样编译器，就能针对这个点单独做出优化，比如这样就不需要在函数末尾出栈和返回，以及针对性的做出指令地址布局的优化。</p>
<p><strong>static_branch_likely</strong> 和 <strong>static_branch_unlikely</strong></p>
<p>在内核中有着两个神奇的宏定义在<code>include/linux/jump_label.h</code>中，这就是<code>static_branch_likely</code>和<code>static_branch_unlikely</code>。这两个宏定义配合Linux内核的跳转表能玩出特别花的动态分支调整，这里的两个宏实际的用法，和上面的<code>LIKELY</code>和<code>UNLIKELY</code>是一样的，在条件判断中添加后用于优化编译后的指令布局。但它强大的地方在于，还提供了另外的接口<code>static_branch_enable</code>和<code>static_branch_disable</code>控制这种优化（还有<code>static_branch_inc</code>和<code>static_branch_dec</code>），在满足特定场景和条件的情况下，开启/关闭分支优化。</p>
<p>下面来看示例代码（从Linux内核摘抄，kvm模块的代码）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_STATIC_KEY_FALSE</span><span class="params">(has_gic_active_state)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_timer_hyp_init</span><span class="params">(<span class="keyword">bool</span> has_gic)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (has_gic) &#123;</span><br><span class="line">        ...</span><br><span class="line">        static_branch_enable(&amp;has_gic_active_state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kvm_timer_vcpu_load</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (static_branch_likely(&amp;has_gic_active_state)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在文件的最开头定义这个动态条件变量默认为<code>false</code>，在初始化的函数中判断是否存在gic，在拥有的情况下会开启这个动态分支优化。下面在kvm模块使用的接口中，会利用<code>static_branch_likely</code>接口判断这个条件变量的使能情况，在上面使能后这里就能通知编译器针对性的优化，如果没使能这里就会按照正常的条件分支做编译处理。</p>
<h3 id="switch的表跳转优化"><a href="#switch的表跳转优化" class="headerlink" title="switch的表跳转优化"></a>switch的表跳转优化</h3><p>写代码过程中常见的“垃圾”代码就是一大串的<code>if-else</code>分支，如果是特别清晰的判断逻辑可能还能接受，一旦判断条件很复杂，简直就是一坨屎山。在这种大量<code>if-else</code>的场景下，也有一种对应的优化手法，那就是转换成<code>switch-case</code>的模式，而超过某个case数量阈值的<code>switch-case</code>能够被编译器自动优化成跳转表的指令格式，这能大量压缩指令数量以及增加条件判断性能。当然，这里你也能手动把<code>if-else</code>改造成跳转表格式，不过这会有点点烧脑，需要构造一会儿。</p>
<p>以下一段代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = some();</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="number">1</span>) &#123;</span><br><span class="line">        ret = ret + some1();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input == <span class="number">2</span>) &#123;</span><br><span class="line">        ret += some2();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input == <span class="number">3</span>) &#123;</span><br><span class="line">        ret += some3();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input == <span class="number">4</span>) &#123;</span><br><span class="line">        ret += some4();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input == <span class="number">5</span>) &#123;</span><br><span class="line">        ret += some5();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input == <span class="number">6</span>) &#123;</span><br><span class="line">        ret += some6();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret += some7();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码如果编译出来后，反汇编查看指令，就能看到其中的<code>if-else</code>全部被转为了cmp指令，会进行多次cmp比较，通过比较的逻辑判断出要跳转的位置，再去执行对应分支上的逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">func:</span><br><span class="line">        stp     x29, x30, [sp, -32]!</span><br><span class="line">        add     x29, sp, 0</span><br><span class="line">        stp     x19, x20, [sp, 16]</span><br><span class="line">        mov     w19, w0</span><br><span class="line">        bl      some</span><br><span class="line">        mov     w20, w0</span><br><span class="line">        cmp     w19, 1</span><br><span class="line">        beq     .L11</span><br><span class="line">        cmp     w19, 2</span><br><span class="line">        beq     .L12</span><br><span class="line">        cmp     w19, 3</span><br><span class="line">        beq     .L13</span><br><span class="line">        cmp     w19, 4</span><br><span class="line">        beq     .L14</span><br><span class="line">        cmp     w19, 5</span><br><span class="line">        beq     .L15</span><br><span class="line">        cmp     w19, 6</span><br><span class="line">        beq     .L16</span><br><span class="line">        bl      some7</span><br><span class="line">        add     w0, w20, w0</span><br><span class="line">.L1:</span><br><span class="line">        ldp     x19, x20, [sp, 16]</span><br><span class="line">        ldp     x29, x30, [sp], 32</span><br><span class="line">        ret</span><br><span class="line">.L14:</span><br><span class="line">        bl      some4</span><br><span class="line">        add     w0, w20, w0</span><br><span class="line">        b       .L1</span><br><span class="line">.L11:</span><br><span class="line">        bl      some1</span><br><span class="line">        add     w0, w0, w20</span><br><span class="line">        ldp     x19, x20, [sp, 16]</span><br><span class="line">        ldp     x29, x30, [sp], 32</span><br><span class="line">        ret</span><br><span class="line">.L12:</span><br><span class="line">        bl      some2</span><br><span class="line">        add     w0, w20, w0</span><br><span class="line">        ldp     x19, x20, [sp, 16]</span><br><span class="line">        ldp     x29, x30, [sp], 32</span><br><span class="line">        ret</span><br><span class="line">.L13:</span><br><span class="line">        bl      some3</span><br><span class="line">        add     w0, w20, w0</span><br><span class="line">        ldp     x19, x20, [sp, 16]</span><br><span class="line">        ldp     x29, x30, [sp], 32</span><br><span class="line">        ret</span><br><span class="line">.L16:</span><br><span class="line">        bl      some6</span><br><span class="line">        add     w0, w20, w0</span><br><span class="line">        ldp     x19, x20, [sp, 16]</span><br><span class="line">        ldp     x29, x30, [sp], 32</span><br><span class="line">        ret</span><br><span class="line">.L15:</span><br><span class="line">        bl      some5</span><br><span class="line">        add     w0, w20, w0</span><br><span class="line">        b       .L1</span><br></pre></td></tr></table></figure>
<p>优化之后，采用<code>switch-case</code>的模式的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = some();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (input) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">          ret += some1();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">          ret += some2();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">          ret += some3();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">          ret += some4();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">          ret += some5();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">          ret += some6();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">          ret = some7();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样再次编译的时候，查看它的反汇编结果，就能看到生成的跳转表（在末尾）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">func:</span><br><span class="line">        stp     x29, x30, [sp, #-32]!</span><br><span class="line">        stp     x20, x19, [sp, #16]</span><br><span class="line">        mov     x29, sp</span><br><span class="line">        mov     w20, w0</span><br><span class="line">        bl      some</span><br><span class="line">        sub     w8, w20, #1</span><br><span class="line">        cmp     w8, #6</span><br><span class="line">        b.hi    .LBB0_3</span><br><span class="line">        adrp    x9, .LJTI0_0</span><br><span class="line">        add     x9, x9, :lo12:.LJTI0_0</span><br><span class="line">        mov     w19, w0</span><br><span class="line">        adr     x10, .LBB0_2</span><br><span class="line">        ldrb    w11, [x9, x8]</span><br><span class="line">        add     x10, x10, x11, lsl #2</span><br><span class="line">        br      x10</span><br><span class="line">.LBB0_2:</span><br><span class="line">        bl      some1</span><br><span class="line">        b       .LBB0_9</span><br><span class="line">.LBB0_3:</span><br><span class="line">        ldp     x20, x19, [sp, #16]</span><br><span class="line">        ldp     x29, x30, [sp], #32</span><br><span class="line">        b       some7</span><br><span class="line">.LBB0_4:</span><br><span class="line">        bl      some2</span><br><span class="line">        b       .LBB0_9</span><br><span class="line">.LBB0_5:</span><br><span class="line">        bl      some3</span><br><span class="line">        b       .LBB0_9</span><br><span class="line">.LBB0_6:</span><br><span class="line">        bl      some4</span><br><span class="line">        b       .LBB0_9</span><br><span class="line">.LBB0_7:</span><br><span class="line">        bl      some5</span><br><span class="line">        b       .LBB0_9</span><br><span class="line">.LBB0_8:</span><br><span class="line">        bl      some6</span><br><span class="line">.LBB0_9:</span><br><span class="line">        add     w0, w0, w19</span><br><span class="line">.LBB0_10:</span><br><span class="line">        ldp     x20, x19, [sp, #16]</span><br><span class="line">        ldp     x29, x30, [sp], #32</span><br><span class="line">        ret</span><br><span class="line">.LBB0_11:</span><br><span class="line">        bl      some6</span><br><span class="line">        sub     w0, w19, w0</span><br><span class="line">        b       .LBB0_10</span><br><span class="line">.LJTI0_0:</span><br><span class="line">        .byte   (.LBB0_2-.LBB0_2)&gt;&gt;2</span><br><span class="line">        .byte   (.LBB0_4-.LBB0_2)&gt;&gt;2</span><br><span class="line">        .byte   (.LBB0_5-.LBB0_2)&gt;&gt;2</span><br><span class="line">        .byte   (.LBB0_6-.LBB0_2)&gt;&gt;2</span><br><span class="line">        .byte   (.LBB0_7-.LBB0_2)&gt;&gt;2</span><br><span class="line">        .byte   (.LBB0_8-.LBB0_2)&gt;&gt;2</span><br><span class="line">        .byte   (.LBB0_11-.LBB0_2)&gt;&gt;2</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>关于这个跳转表优化，我在实际测试的过程中发现它和编译器的版本强相关。在比较新的编译器clang或者gcc高版本上做测试时，在不开启高优化选项时，也能针对<code>if-else</code>分支做跳转表优化。这说明编译器本身的优化能力也是在版本升级的过程中，不断地增强迭代。可能现阶段使用较新编译器的情况下，该条优化建议所能产生的价值较为有限。</p>
<h3 id="循环行为优化"><a href="#循环行为优化" class="headerlink" title="循环行为优化"></a>循环行为优化</h3><p><strong>提取循环中的无关操作</strong></p>
<p>使用了循环语句，说明循环内部的操作是需要反复执行的内容，这段内容越精简也会使得整体的效率越高。但是如何精简呢？方向大致上是：</p>
<ul>
<li>循环的判断条件</li>
<li>循环体内的计算</li>
</ul>
<p>如果存在每次循环中都是相同的内容，可以抽离出循环体外。给一段示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        a[i] = b[i] * some_value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化其中共同的计算内容后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp =  some_value();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        a[i] = b[i] * temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>地址小偏移和多次数循环尽量在内层</strong></p>
<p>可以结合<code>cache优化</code>章节的内容一起学习，这里将地址小偏移以及循环次数多的内容放在循环内层中，为了更多的保证cache的命中率，同时内层循环次数多，外层循环次数少，也就意味着外层的条件判断相关内容执行的少，这样反而能少一点循环变量初始化的指令执行。</p>
<p>示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        sum += input[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化之后的代码，把循环的遍历方式调整为以行遍历为准，以列遍历的方式一方面会增加循环变量的初始化次数，另外一方面会减少cache的命中率（详细见<code>cache优化</code>章节）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">        sum += input[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>循环合并</strong></p>
<p>顾名思义，将多个相关联的循环语句合并为一个循环语句，这样带来的好处是判断条件导致的开销只会剩下一个循环的，不会有其他循环的条件判断指令造成额外开销。但这是一把双刃剑，循环体内部的语句膨胀之后，会造成指令cache命中率下降，这会是另外一种形式的性能损耗。</p>
<p>示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    sum1 += a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    sum2 += b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化之后的代码，将两个循环合并为了一个循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    sum1 += a[i];</span><br><span class="line">    sum2 += b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数设计"><a href="#函数设计" class="headerlink" title="函数设计"></a>函数设计</h3><p><strong>少用结构体等大数据类型的直接参数传递</strong></p>
<p>在C语言中参数传递的方式，主要有值传递和指针传递。其中值传递的方式，是会将参数传递的值拷贝到栈空间上暂存，这会导致两个问题。一是拷贝数据的动作会造成性能开销，二是暂存在栈空间也是对栈的消耗，当传入的结构体超大时容易出现爆栈情况。而对于指针传递，只需要考虑指针的大小，这通常为4字节(32位)/8字节(64位)，不需要占用过多的拷贝时间，也不需要特别大的栈空间开销。</p>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(struct my_struct my_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"id: %d, name: %s\n"</span>, my_info.id, my_info.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从传入结构体修改为传入指针类型，但更好的方式是在这种只读场景下添加<code>const</code>修饰符，把它当做常量来使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(struct my_struct *my_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"id: %d, name: %s\n"</span>, my_info-&gt;id, my_info-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>性能敏感路径上的函数内联</strong></p>
<p>函数内联是一种非常常见的优化手段，在各种开源项目中都会有一些<code>inline</code>修饰符的函数，这个就是选择了内联的函数。内联函数在编译之后会被展开，也就是说在完成编译后这个函数会消失，在调用点变成相应的执行语句。这个的好处，显而易见的是没有了函数压栈和出栈的开销，在性能敏感的路径上少几条指令就会迎来质变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hot_func</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    do_some_thing(value);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用函数内联也会带来一些风险和麻烦。</p>
<ol>
<li>调试的麻烦。函数内联后，在获取二进制进行反汇编或者用gdb调试时不一定能精准的识别出这里的代码位置，在标记内联后编译器还会做一些优化处理，这会使得调试信息符号可能出现问题。</li>
<li>热补丁的麻烦。有些程序为了运行稳定，需要使用热补丁做动态程序漏洞修补，函数内联后会更加难以定位出具体的代码位置，如果是内联函数出了漏洞bug，将难以直接热补丁修复。</li>
<li>体积上的风险。这里函数内联的本质和宏定义展开是类似的情况，它是不会复用这段代码指令，而是把调用点全部替换为相同的执行语句，这就会带来程序体积上的增长。</li>
</ol>
<h3 id="结构体设计"><a href="#结构体设计" class="headerlink" title="结构体设计"></a>结构体设计</h3><p>这点在设计结构体成员的时候就有所体现了，大部分常见的开源软件，他们的结构体设计都是相关联的成员变量离得很近，这也是为了CPU里的数据cache加速。当我们访问结构体时，成员变量靠近就会很大概率存储在同一个cache里，这样访问其中的数据就不会导致cache未命中。相反，如果在设计结构体时，两个变量离的很远，就会造成cache未命中，引起CPU内部的cache刷新，降低了数据访问性能。</p>
<p>示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_value_list</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> keys[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> values[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>优化之后，把其中的公共字段提取出来，成为一个单独的结构体，然后再声明一个新的数组。这样，每次访问结构体的<code>key</code>和<code>value</code>，都在附近的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_value_pair</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_value_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key_value_pair</span> <span class="title">pairs</span>[100];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="简化冗余行为"><a href="#简化冗余行为" class="headerlink" title="简化冗余行为"></a>简化冗余行为</h3><p><strong>不必要的初始化行为</strong></p>
<p>如果某个变量声明后做了初始化，第一次使用也是直接对其做赋值，那么这个初始化的行为则没有意义。针对这种情况，在变量声明时就不应该做初始化动作，这样能节省初始化的开销。</p>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum = get_sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化<code>sum</code>之后，马上又对其做赋值，这里就能直接优化掉<code>sum</code>的初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = get_sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>减少内存段擦写</strong></p>
<p>在程序中大量的<code>memset</code>和<code>memcpy</code>等行为，会严重拖慢整体的速度，所以这种内存段擦写和拷贝动作，需要考虑他们的重要性。针对安全性不高的临时数据，没必要在每次操作前都覆盖一遍。</p>
<p>针对字符串，可以通过末尾的<code>\0</code>来截断字符串的解析，以此屏蔽字符串末尾后面的无效数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    ptr[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="comment">// memset(ptr, 0, 100);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>密钥，密码，校验hash值等安全相关的缓存数据，应该要及时清理。</p>
<p><strong>减少重复计算</strong></p>
<p>这点和上文提到的利用局部变量缓存的机制很类似，局部变量缓存也是实现减少重复计算的方式之一。除了局部变量减少重复计算，还有全局变量，静态变量或者常量的方式。这些动作的优化，都是为了减少重复的工作量，提升程序整体的计算性能。</p>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = get_sum();</span><br><span class="line">    <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (sum * <span class="number">8</span> - <span class="number">5</span>); i++) &#123;</span><br><span class="line">        output += something();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化之后，同样使用局部变量的方式替换重复的计算过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = get_sum();</span><br><span class="line">    <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_loop = sum * <span class="number">8</span> - <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_loop; i++) &#123;</span><br><span class="line">        output += something();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>条件判断的短路效应</strong></p>
<p>在C语言的逻辑判断中如果是与（&amp;&amp;）的逻辑判断，在其中第一个条件失败时就不会再进行后面的条件计算，这就是短路效应。利用这种短路效应，也是一种能够节省计算的方法，能减少一部分表达式的求值计算。与此对应，或（||）的逻辑判断中，只有当第一个条件判断失败之后，才会进行第二个条件的计算。</p>
<p>以下示例代码中展示了一个条件与的判断场景，<code>check_a</code>和<code>check_b</code>的两个逻辑判断。这里，<code>check_a</code>如果失败的可能性比<code>check_b</code>更大，那么它就应该放在前面，这样它一旦失败之后，就不会再判断后面的条件内容<code>check_b</code>了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (check_a() &amp;&amp; check_b()) &#123;</span><br><span class="line">        something();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cache优化"><a href="#cache优化" class="headerlink" title="cache优化"></a>cache优化</h2><p>非常推荐陈浩大佬写的<a href="https://coolshell.cn/articles/20793.html" target="_blank" rel="noopener">CPU缓存知识文章</a>，里面从浅入深讲述了CPU的cache知识。里面举例了几个经典的cache案例，涉及体系结构中的CPU设计，包括CPU cache line大小和CPU ways数量。有个网站叫做wikichip，能够查询CPU的基本信息，其中有缓存大小和ways数量，但没cache line的描述，估计大部分主流CPU都是64字节的设计，我自己的macbook-15 2018款i7的信息是<a href="https://en.wikichip.org/wiki/intel/core_i7/i7-8750h" target="_blank" rel="noopener">Core i7-8750H</a>。</p>
<p>这里提到的cache优化主要分为两个方面：</p>
<ol>
<li>数据访问步长过大导致的cache命中率低下</li>
<li>多线程场景下写入共同数据时，多核CPU间相同cache数据同步导致的cache利用率不高</li>
</ol>
<h3 id="访问步长导致的cache问题"><a href="#访问步长导致的cache问题" class="headerlink" title="访问步长导致的cache问题"></a>访问步长导致的cache问题</h3><p>直接上代码，这里用了两层循环，外面一层循环为执行<code>10000000</code>次任务，里面一层循环是以<code>increment</code>的步长，每轮任务<code>count</code>次数来访问<code>memory</code>数组中的数据，并写入新的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j += increment) &#123;</span><br><span class="line">        memory[j] += j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，引用陈浩大佬的通俗计算公式。</p>
<blockquote>
<p>Intel 大多数处理器的L1 Cache都是32KB，8-Way 组相联，Cache Line 是64 Bytes。这意味着，</p>
<ul>
<li>32KB的可以分成，32KB / 64 = 512 条 Cache Line。</li>
<li>因为有8 Way，于是会每一Way 有 512 / 8 = 64 条 Cache Line。</li>
<li>于是每一路就有 64 x 64 = 4096 Byts 的内存。</li>
</ul>
</blockquote>
<p>这里能够知道大部分场景下，设计出的一路缓存Cache是4KB的大小，这也刚好和大多数的页大小一致。因此，如果这里的<code>count</code>大于8，<code>increment</code>为1024，也就是4KB的步长，就会出现所有的Ways被用完的情况，从而引发cache冲突失效。</p>
<p>同理，还有另外一种二维数组的遍历场景。逐行遍历和逐列遍历的方式在性能上也会出现跨列时步长过大，引起cache大量冲突失效的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> row = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> col = <span class="number">512</span></span><br><span class="line"><span class="keyword">int</span> matrix[row][col];</span><br><span class="line"></span><br><span class="line"><span class="comment">//逐行遍历</span></span><br><span class="line"><span class="keyword">int</span> sum_row=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> _r=<span class="number">0</span>; _r&lt;row; _r++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> _c=<span class="number">0</span>; _c&lt;col; _c++)&#123;</span><br><span class="line">        sum_row += matrix[_r][_c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逐列遍历</span></span><br><span class="line"><span class="keyword">int</span> sum_col=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> _c=<span class="number">0</span>; _c&lt;col; _c++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> _r=<span class="number">0</span>; _r&lt;row; _r++)&#123;</span><br><span class="line">        sum_col += matrix[_r][_c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对这种场景出现的性能问题，我们的优化方案会很直接。</p>
<ol>
<li><strong>优化步长</strong>。如果步长能够被压缩，则尽可能的小，以此能在同一个4KB缓存中出现。</li>
<li><strong>优化遍历方式</strong>。尽量实现连续的内存访问，而不是跳跃式的内存访问。</li>
</ol>
<h3 id="多线程写入导致的cache问题"><a href="#多线程写入导致的cache问题" class="headerlink" title="多线程写入导致的cache问题"></a>多线程写入导致的cache问题</h3><p>第二个可能出现cache问题的情况，是多个线程去访问了相邻的数据内容，并且其中有写入行为。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span> <span class="params">(<span class="keyword">int</span>* data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>; ++i)</span><br><span class="line">        *data += rand();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;p[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> *p2 = &amp;p[<span class="number">1</span>]; <span class="comment">// int *p2 = &amp;p[30];</span></span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(fn, p1)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(fn, p2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>由于Cache Line 是64 Bytes，这里的<code>p[0]</code>和<code>p[1]</code>都在同一块Cache中，而这里多线程反复修改会造成CPU Cache失效，多线程任务会跑在不同核的CPU上，这就使得CPU之间的Cache需要做同步，这种同步产生在两个CPU的L1和L2 Cache中，效率严重下降。</p>
<p>如果将<code>p[1]</code>替换为<code>p[30]</code>，30和0之间的差距30 * 4 = 120 Bytes，这就使得两个不在同一块Cache中，分别对其做更新写入时不会影响另外一块Cache的情况。</p>
<p>大部分的CPU模型是分为L1、L2、L3三层模型，其中L1和L2是单核使用，L3一般是所有核公用。上方的多线程读写就会使得不同核心间的数据产生差异，CPU在处理这种场景时就涉及到数据状态标记的状态转换。再次引用陈浩大佬的介绍内容，用一个最简单的状态协议做个初步介绍，更详细内容建议阅读原文。</p>
<blockquote>
<p>这里介绍几个状态协议，先从最简单的开始，MESI协议，这个协议跟那个著名的足球运动员梅西没什么关系，其主要表示缓存数据有四个状态：Modified（已修改）, Exclusive（独占的）,Shared（共享的），Invalid（无效的）。</p>
</blockquote>
<img src="/2024/12/31/C-language-performance-optimization-guide/image-20241106232827507.png">
<p>强大的MESI动画网站，清楚的展示了不同CPU之间的数据读写如何同步 <a href="https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESIHelp.htm" target="_blank" rel="noopener">https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESIHelp.htm</a></p>
<h3 id="一些趣事"><a href="#一些趣事" class="headerlink" title="一些趣事"></a>一些趣事</h3><p>根据我自己的经历，cache优化还和指令对齐相关。这里提两个我在工作上遇到的两个性能问题：</p>
<p>一个是在某产品的特定硬件上出现了性能普遍劣化1.5-2%，而这个劣化是由于top工具的采样不准确导致的。在不断地测试中发现，这个不准确是因为采样频率刚好和进程切换相撞，让top统计时认为该进程还在运行，但实际上运行时间并没有那么长。最后是强行用了一种trick的方式，强行加无效指令做对齐让top统计结果恢复正常。</p>
<p>第二个是我手上看护的某个特性，会在程序中做指令级插桩，而插桩的内容中刚好包含align对齐指令。这个对齐通常情况下不会有额外的副作用，但在某些特殊情况下会因为对齐使得某部分代码刚好超出页大小，在执行相关流程时需要多分配页外加是性能敏感路径，这就导致性能下降。</p>
<h2 id="并发处理优化"><a href="#并发处理优化" class="headerlink" title="并发处理优化"></a>并发处理优化</h2><h3 id="并发的无锁实现"><a href="#并发的无锁实现" class="headerlink" title="并发的无锁实现"></a>并发的无锁实现</h3><p>无锁实现指的是通过限制某个变量只能被特定的对象访问，以此来取代需要加锁保护再来访问的情况。控制访问来源，这样在并发场景下就无需再加锁。这种实现能避免复杂的加锁解锁的代码，简化了代码逻辑又能保持良好的可维护性，为后续的功能开发不会带来太大的历史包袱。</p>
<p><strong>单生产者 单消费者模型</strong></p>
<p>这种模型的理念是有多少个生产者就对应有多少个消费者，并且某个生产者A生产的内容，只会被对应的某个消费者a获取，别的消费者b无法访问生产者A的内容。简化成示意图如下：</p>
<img src="/2024/12/31/C-language-performance-optimization-guide/iShot2024-12-01_15.32.39.png">
<p>在这种场景下，每个生产者和消费者都是依靠索引访问，这样每对生产者消费者不会互相干扰，在这样的并发情况下，也是由多个线程去执行多对不同的生产者消费者流程，可以不用加锁去保护其中的数据内容。</p>
<p><strong>线程变量</strong></p>
<p>gcc中提供的关键字<code>__thread</code>，可以用于线程级别的变量。被<code>__thread</code>标记的变量在每个线程中都是一份独立的存储，这样能使得线程之间不会互相干扰。在这种情况下，多线程并发时，对于这种线程变量的读写访问是不需要加锁保护。</p>
<p>但该关键字存在一些限制与约束：</p>
<ul>
<li>只能修饰基础数据类型，不能修饰复杂数据结构（比如结构体、类等）</li>
<li>不能修饰函数局部变量或者类的普通成员变量</li>
</ul>
<p>本质上是对一些全局性的变量做标记，比如全局变量和静态变量。让编译器能自动帮助程序员使用空间换时间，得到更大的性能。</p>
<p><strong>CPU变量</strong></p>
<p>Linux内核中提供的一个神奇机制PER_CPU变量，为每个CPU都创建变量的独立副本。这样在跑多线程任务或者多进程任务时，每个CPU所访问到的都是唯一的副本。这里的设计和上面的线程变量<code>__thread</code>非常类似，都是用时间换空间的典型。</p>
<p>具体的代码实现，面对定义为PER_CPU的变量，内核会根据CPU的数量创建对应大小的数组，每个CPU只会访问其中的一个元素，这样CPU之间的任务不会互相干扰。</p>
<p>当然有的人可能会和我一开始了解时有着同样的疑问，这个明明是针对CPU的变量，为啥也可以做到无锁且不会有并发问题？原因是这里一旦开始访问PER_CPU变量时，内核会关闭该CPU的抢占，这样在该CPU上执行的任务就不会被其他高优先级进程抢占，当进程切换出去后，又被切到另外一个CPU上导致数据出现同步问题。</p>
<p>使用这种CPU变量需要注意的点是需要用内核提供的专用API接口，包括变量的定义，变量的指针提取，读取变量的值，释放变量等等。</p>
<p><strong>注意</strong></p>
<p>现代CPU中的乱序执行会影响以上的优化方案，最经典的例子就是内存操作中出现的乱序执行，造成程序出现预期之外的行为。</p>
<p>比如，先对某个变量写入一个值，再读取这个变量，一个典型的单生产者单消费者场景。如果出现了乱序情况，就会出现读取操作在写入之前。当然，这里的例子比较极端，单变量访问出现的可能性比较小，一般是复杂的结构体数据或者是大段数组空间写入时，会出现乱序执行造成异常。</p>
<h3 id="并发的免锁实现"><a href="#并发的免锁实现" class="headerlink" title="并发的免锁实现"></a>并发的免锁实现</h3><p>使用不同架构提供的CAS（Compare-And-Swap）指令实现的免锁互斥访问机制。这里需要知道，大多数编程语言只有最基础的一项操作是原子性的。通常有以下行为是原子性操作：</p>
<ul>
<li>赋值动作（int x = 1;）</li>
<li>加减法（1 + 2）</li>
<li>自增/自减 ++/–</li>
<li>读取变量操作</li>
</ul>
<p>但将以上组合在一起的行为并不是原子性操作，比如从一个变量中读取数据，对其做计算，并写入到另外一个变量中时（a = b + 1），这个并不是一个原子操作。所以针对这种语句是需要额外的机制来保证它的原子性，这也是免锁要实现的目标。</p>
<p>大多数编程语言和开源软件已经提前实现好原子操作的库，这种操作库提供了诸如<code>atomic_read</code>，<code>atomic_write</code>等操作去无锁化访问存在并发的共享数据，并且可以保证不出现并发问题。但这种原子操作存在一种约束，既是只能针对基础变量类型达到原子操作化，复杂类型的数据结构，比如结构体，类等等无法应用。除了上述的原子操作库，还有多生产者多消费者框架（FIFO queues、RCU）也是有类似的实现方案。</p>
<p><strong>注意</strong></p>
<p>存在ABA问题，也就是乱序执行发生时，CAS指令无法感知识别到原始数据已经被修改，只会根据它当时读取的值来做判断。这种时候只能添加屏障指令来让编译器和CPU不针对这里做优化，以此来防止乱序执行。</p>
<h3 id="最小化加锁区间"><a href="#最小化加锁区间" class="headerlink" title="最小化加锁区间"></a>最小化加锁区间</h3><p>首先，C语言的生态中有着不同类型的锁，不同锁的应用场景有着一定区别。使用合适自己场景的锁，并在对应的中尽量最小化这个临界区间。</p>
<p><strong>自旋锁 spin lock</strong></p>
<p>一直持有CPU资源的锁方案，自旋锁上锁之后，没有持锁的进程请求自旋锁是不会被调度出去，请求锁的进程会一直占有CPU资源做等待，直到有人释放了自旋锁。自旋锁大量应用在内核之中，用于关闭中断等不能被调度出去的场景下访问临界区资源。</p>
<p><strong>互斥锁 mutex lock</strong></p>
<p>和自旋锁相反，它是不会一直持有CPU资源的锁方案，互斥锁上锁后没有持锁的进程请求互斥锁会出现进程调度休眠，释放该进程的CPU资源给其他进程使用。相比自旋锁，互斥锁的阻塞状态不会有大量的CPU开销。互斥锁大量应用于一般的加锁场景中，包括各类常规的全局变量访问等等。</p>
<p><strong>读写锁 read-write lock</strong></p>
<p>除了上面两种最基础的锁，还有一种读写锁。内核中有大概有两种实现，一种是常规的读写锁<code>rwlock_t</code>，另外有一种特殊的为类似读写场景服务的锁<code>rcu_lock</code>，也被称为RCU锁。在实际使用过程中，大部分场景都会采用RCU锁去做多读少写的并发锁。网上有一张非常直观的图来区分这两种不同的锁：</p>
<img src="/2024/12/31/C-language-performance-optimization-guide/image-20241231003432134.png">
<p><strong>使用技巧总结</strong></p>
<ol>
<li>自旋锁应用在快速使用，快速释放的场景，由于该锁会消耗CPU资源的特性不宜长时间占有。自旋锁也可用在各种不能进入休眠或者调度的场景中，互斥锁一旦阻塞会使得进程进入休眠，而自旋锁就不会有这种问题；</li>
<li>互斥锁是所有锁之中开销最大的锁，不仅仅是锁本身的性能开销较大，还因为互斥锁在产生冲突阻塞之后造成的系统调度等一系列开销。所以在使用过程中，需要十分的仔细确是否有必要一定要使用互斥锁做临界区保护；</li>
<li>RCU锁是Linux内核实现的一种特殊机制锁，用于解决常规读写锁开销大的弊病。因此，能使用读写锁的场景都能使用RCU锁直接代替，以此实现性能上的优化；</li>
</ol>
<h2 id="高效算法优化"><a href="#高效算法优化" class="headerlink" title="高效算法优化"></a>高效算法优化</h2><h3 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h3><p>使用位操作为基础的计算方式，在现代计算机中能够实现天然的并行化处理，寄存器中的bit位数值是可以一口气进行设置，而不需要进行多次分布计算。</p>
<p>用位运算设置一段bit区间，常规的做法是做一遍循环去逐bit设置值。但如果用位操作优化就可得到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化前</span></span><br><span class="line">uint result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    result |= (uint)(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT_RANGE_SET(max_bit, from, to) (~0 &gt;&gt; (max_bit - (to -from))) &lt;&lt; from</span></span><br><span class="line"></span><br><span class="line">BIT_RANGE_SET(uint, start, end)</span><br></pre></td></tr></table></figure>
<p>除此之外，现代CPU针对位操作还有极好的优化指令，能够快速提升运算速度，这也是做高性能计算的关键点。比如以下几个编译器中的内构函数：</p>
<ul>
<li><code>__builtin_ffs</code>：寻找无符号整数从低位开始的第一个二进制位为1的位置</li>
<li><code>__builtin_clz</code>：计算无符号整数中从最高位开始连续的0个数</li>
<li><code>__builtin_ctz</code>：计算无符号整数中从最低位开始连续的0个数</li>
<li><code>__builtin_popcount</code>：计算无符号整数二进制表示中1的个数</li>
</ul>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分的思想广泛应用在计算机的世界中，存在固定排序的数据中每次只看数据中间的值，根据与中间的值比较来进一步切分下一次要二分的区间，通过不断地二分比较以此来搜索最优的数据内容。这里就简单给一段示例代码说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input </span></span><br><span class="line"><span class="comment">// 排序好的数组 int *data</span></span><br><span class="line"><span class="comment">// 数组的大小 size_t size</span></span><br><span class="line"><span class="comment">// 需要搜索的数据 n</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = size - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> ((right - left) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> middle = (right + left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="built_in">array</span>[middle]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>[middle];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="built_in">array</span>[middle]) &#123;</span><br><span class="line">        left = middle;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right = middle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">array</span>[right];</span><br></pre></td></tr></table></figure>
<p>除了查找数据，有些时候在排查引入问题的commit提交时，二分commit内容也是一种很好的思路，这样只需要少量尝试就能知道有问题的commit是在什么区间之中，帮助我们锁定问题范围。比如git提供的<code>git bisect</code>命令。</p>
<h3 id="函数拟合"><a href="#函数拟合" class="headerlink" title="函数拟合"></a>函数拟合</h3><p>如果学习过高数，我们能够知道有些时候能用一些多项式函数拟合一些计算较为复杂的函数表达式，当这些多项式函数的误差在可接受的范围内，可使用这种方式来做性能优化。</p>
<p>这里涉及到很多数学方面的证明和推导，这里就不过多阐述这种事情。（留给专业的人来做吧，我的高数也忘的差不多了）这里唯一需要注意的事情，拟合之后的多项式函数需要有相关的设计文档和代码注释来说明这些特殊表达式的含义，大部分看代码的人是无法直接理解这些多项式的背景和含义。</p>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>憋了好久终于又来了一篇，想要平衡工作、学习、生活，对于一个社畜来说还是一件非常有挑战的事情呢。人的精力在工作上就被榨干的差不多了，还要抽空来跟踪最新的知识和学习其他额外内容就会显得疲惫，希望能够挺过来吧。（终于拖到2024年的最后一天发出来了）</p>
<p>坚持自己热爱的事情，相信自己脚下走的路。</p>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="https://hurricane618.me">hurricane618</a>
            </p><p>原文链接：<a href="https://hurricane618.me/2024/12/31/C-language-performance-optimization-guide/">https://hurricane618.me/2024/12/31/C-language-performance-optimization-guide/</a>
            </p><p>发表日期：<a href="https://hurricane618.me/2024/12/31/C-language-performance-optimization-guide/">December 31st 2024, 11:12:38 pm</a>
            </p><p>更新日期：<a href="https://hurricane618.me/2024/12/31/C-language-performance-optimization-guide/">December 31st 2024, 11:12:38 pm</a>
            </p><p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/2024/05/05/pointer-authentication-collection-1/" title="ARM安全特性PA(Pointer Authentication)的技术洞察">
                    <div class="prevTitle">ARM安全特性PA(Pointer Authentication)的技术洞察</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    <div id="disqus_thread"></div>
    <script>
        /**
    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
        
        var disqus_config = function () {
        this.page.url = "https://hurricane618.me/2024/12/31/C-language-performance-optimization-guide/";  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = "C语言性能优化指南"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };
        
        (function () { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');
            s.src = 'https://hurricane618.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();

    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:hurricane618@hotmail.com" class="iconfont-archer email" title="email"></a>
            
        
    
        
            
                <a href="//github.com/hurricane618" class="iconfont-archer github" target="_blank" title="github"></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="//twitter.com/hurricane_618" class="iconfont-archer twitter" target="_blank" title="twitter"></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="/atom.xml" class="iconfont-archer rss" target="_blank" title="rss"></a>
            
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a> record <a href="https://beian.miit.gov.cn">蜀ICP备17007526号</a> </span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">已经有 <span id="busuanzi_value_site_pv"></span> 个不明生物光临此地</span>
    
    </div>
    
</footer>

    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编译选项"><span class="toc-number">2.</span> <span class="toc-text">编译选项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通用编译优化-O"><span class="toc-number">2.1.</span> <span class="toc-text">通用编译优化 -O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指令架构优化-march"><span class="toc-number">2.2.</span> <span class="toc-text">指令架构优化 -march</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链接优化-flto"><span class="toc-number">2.3.</span> <span class="toc-text">链接优化 -flto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关闭安全选项（不推荐）"><span class="toc-number">2.4.</span> <span class="toc-text">关闭安全选项（不推荐）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编码优化"><span class="toc-number">3.</span> <span class="toc-text">编码优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#局部变量缓存"><span class="toc-number">3.1.</span> <span class="toc-text">局部变量缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标记条件分支"><span class="toc-number">3.2.</span> <span class="toc-text">标记条件分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch的表跳转优化"><span class="toc-number">3.3.</span> <span class="toc-text">switch的表跳转优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环行为优化"><span class="toc-number">3.4.</span> <span class="toc-text">循环行为优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数设计"><span class="toc-number">3.5.</span> <span class="toc-text">函数设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体设计"><span class="toc-number">3.6.</span> <span class="toc-text">结构体设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简化冗余行为"><span class="toc-number">3.7.</span> <span class="toc-text">简化冗余行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cache优化"><span class="toc-number">4.</span> <span class="toc-text">cache优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#访问步长导致的cache问题"><span class="toc-number">4.1.</span> <span class="toc-text">访问步长导致的cache问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程写入导致的cache问题"><span class="toc-number">4.2.</span> <span class="toc-text">多线程写入导致的cache问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一些趣事"><span class="toc-number">4.3.</span> <span class="toc-text">一些趣事</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发处理优化"><span class="toc-number">5.</span> <span class="toc-text">并发处理优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#并发的无锁实现"><span class="toc-number">5.1.</span> <span class="toc-text">并发的无锁实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发的免锁实现"><span class="toc-number">5.2.</span> <span class="toc-text">并发的免锁实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最小化加锁区间"><span class="toc-number">5.3.</span> <span class="toc-text">最小化加锁区间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#高效算法优化"><span class="toc-number">6.</span> <span class="toc-text">高效算法优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#位操作"><span class="toc-number">6.1.</span> <span class="toc-text">位操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二分查找"><span class="toc-number">6.2.</span> <span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数拟合"><span class="toc-number">6.3.</span> <span class="toc-text">函数拟合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#后话"><span class="toc-number">7.</span> <span class="toc-text">后话</span></a></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 40
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2024 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/31</span><a class="archive-post-title" href="/2024/12/31/C-language-performance-optimization-guide/">C语言性能优化指南</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/05</span><a class="archive-post-title" href="/2024/05/05/pointer-authentication-collection-1/">ARM安全特性PA(Pointer Authentication)的技术洞察</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2023 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/03</span><a class="archive-post-title" href="/2023/10/03/my-recommendation-list-1/">那些年我看过的番剧、电视剧、电影以及玩过的游戏</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/17</span><a class="archive-post-title" href="/2023/06/17/makefile-study-notes/">Makefile学习笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/14</span><a class="archive-post-title" href="/2023/03/14/selinux-source-code-kernel-part/">SELinux源码分析--内核态</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2022 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/27</span><a class="archive-post-title" href="/2022/11/27/seven-years-of-my-life1/">我的人生七年（一）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/18</span><a class="archive-post-title" href="/2022/11/18/ios-system-security-framework-study-1/">iOS系统安全框架演进学习</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/26</span><a class="archive-post-title" href="/2022/05/26/pwn-college-writeup-one/">pwn.college 学习笔记（1）</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2021 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/08</span><a class="archive-post-title" href="/2021/12/08/2021-autunm-recruitment-summary/">一个双非安全菜鸡的秋招总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/09</span><a class="archive-post-title" href="/2021/06/09/2021-face-has-some-problems/">记最近一个月面瘫那点事</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/15</span><a class="archive-post-title" href="/2021/05/15/hw2021-summary/">hw2021 蓝队总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/28</span><a class="archive-post-title" href="/2021/04/28/linux-kernel-security-summary/">Linux 内核安全机制总结</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/17</span><a class="archive-post-title" href="/2020/12/17/2020xhlj-iot-pwn/">西湖论剑 IoT闯关赛 2020 pwn3 ezarmpwn</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/26</span><a class="archive-post-title" href="/2020/10/26/2020-bytectf-gun/">2020 bytectf gun writeup</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/12</span><a class="archive-post-title" href="/2020/10/12/2020-tctf-final-jit/">2020 TCTF final SecureJIT writeup</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/15</span><a class="archive-post-title" href="/2020/09/15/2020qwb-qwxf-pwn/">2020强网杯 强网先锋のpwn</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/07</span><a class="archive-post-title" href="/2020/08/07/glibc-pwn-off-by-one-1/">glibc堆利用之off by one的两道CTF题目</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/01</span><a class="archive-post-title" href="/2020/08/01/2020rctf-some-pwn/">2020RCTF 几道pwn题的复现</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/13</span><a class="archive-post-title" href="/2020/01/13/algorithm-course-summary/">算法课程总结</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/27</span><a class="archive-post-title" href="/2019/11/27/docker-mysql-problem-check/">Docker中的Mysql配置问题处理与思考</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/11</span><a class="archive-post-title" href="/2019/11/11/cnss-recruit-pwn-1/">CNSS招新题中的一道ROP题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/14</span><a class="archive-post-title" href="/2019/09/14/fancy-rop-practice/">花式栈溢出学习</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/26</span><a class="archive-post-title" href="/2019/07/26/basic-rop-practice/">基础ROP学习</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/24</span><a class="archive-post-title" href="/2019/05/24/2019rctf-some-writeup/">2019RCTF 部分Web的WriteUp</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/29</span><a class="archive-post-title" href="/2019/04/29/2019ddctf-unsolved-writeup/">2019DDCTF 未解决的web题 writeup</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/19</span><a class="archive-post-title" href="/2019/04/19/2019ddctf-my-solutions-writeup/">2019DDCTF 部分我解决的题目writeup</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/31</span><a class="archive-post-title" href="/2019/03/31/2019TCTF-web-writeup/">2019TCTF web writeup</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/02</span><a class="archive-post-title" href="/2019/03/02/serial-ports-translation-cn/">快速寻找串行接口</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/18</span><a class="archive-post-title" href="/2019/02/18/yingshi-camera-firmware-extract/">萤石某摄像头的安全分析--固件提取</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/03</span><a class="archive-post-title" href="/2019/02/03/thinkphp-5-0-23-rce/">thinkphp 5.0.23 rce分析和复现</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/27</span><a class="archive-post-title" href="/2019/01/27/haozi-xss-challenges/">haozi xss 挑战赛 writeup</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/24</span><a class="archive-post-title" href="/2019/01/24/code-breaking-lumenserial/">code-breaking lumenserial 复现</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/10</span><a class="archive-post-title" href="/2019/01/10/code-breaking-esay-wp/">code-breaking easy部分题目writeup</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/15</span><a class="archive-post-title" href="/2018/08/15/google-ctf-beginner-part2/">Google CTF Beginner Part2</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/01</span><a class="archive-post-title" href="/2018/08/01/dianfengjikeCTF-web/">巅峰极客CTF 部分Web复现</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/18</span><a class="archive-post-title" href="/2018/07/18/google-ctf-beginner-part1/">Google CTF Beginner Part1</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/08</span><a class="archive-post-title" href="/2018/07/08/google-ctf-beginner-js-safe-1/">Google CTF Beginner JS Safe 1 复现</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/01</span><a class="archive-post-title" href="/2018/07/01/phpmyadmin4-8-1-background-LFI/">phpmyadmin4.8.1 后台LFI</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/30</span><a class="archive-post-title" href="/2018/06/30/csp-bypass-summary/">CSP绕过总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/26</span><a class="archive-post-title" href="/2018/06/26/new-start/">新的开始</a>
        </li>
    
    </ul></div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="Kernel"><span class="iconfont-archer">&#xe606;</span>Kernel</span>
    
        <span class="sidebar-tag-name" data-tags="调试"><span class="iconfont-archer">&#xe606;</span>调试</span>
    
        <span class="sidebar-tag-name" data-tags="CTF"><span class="iconfont-archer">&#xe606;</span>CTF</span>
    
        <span class="sidebar-tag-name" data-tags="PHP"><span class="iconfont-archer">&#xe606;</span>PHP</span>
    
        <span class="sidebar-tag-name" data-tags="JAVA"><span class="iconfont-archer">&#xe606;</span>JAVA</span>
    
        <span class="sidebar-tag-name" data-tags="fmt"><span class="iconfont-archer">&#xe606;</span>fmt</span>
    
        <span class="sidebar-tag-name" data-tags="算法"><span class="iconfont-archer">&#xe606;</span>算法</span>
    
        <span class="sidebar-tag-name" data-tags="闲聊"><span class="iconfont-archer">&#xe606;</span>闲聊</span>
    
        <span class="sidebar-tag-name" data-tags="代码审计"><span class="iconfont-archer">&#xe606;</span>代码审计</span>
    
        <span class="sidebar-tag-name" data-tags="ROP"><span class="iconfont-archer">&#xe606;</span>ROP</span>
    
        <span class="sidebar-tag-name" data-tags="stackoverflow"><span class="iconfont-archer">&#xe606;</span>stackoverflow</span>
    
        <span class="sidebar-tag-name" data-tags="docker"><span class="iconfont-archer">&#xe606;</span>docker</span>
    
        <span class="sidebar-tag-name" data-tags="Mysql"><span class="iconfont-archer">&#xe606;</span>Mysql</span>
    
        <span class="sidebar-tag-name" data-tags="hw"><span class="iconfont-archer">&#xe606;</span>hw</span>
    
        <span class="sidebar-tag-name" data-tags="总结"><span class="iconfont-archer">&#xe606;</span>总结</span>
    
        <span class="sidebar-tag-name" data-tags="makefile"><span class="iconfont-archer">&#xe606;</span>makefile</span>
    
        <span class="sidebar-tag-name" data-tags="IOT"><span class="iconfont-archer">&#xe606;</span>IOT</span>
    
        <span class="sidebar-tag-name" data-tags="heap"><span class="iconfont-archer">&#xe606;</span>heap</span>
    
        <span class="sidebar-tag-name" data-tags="ARM"><span class="iconfont-archer">&#xe606;</span>ARM</span>
    
        <span class="sidebar-tag-name" data-tags="CSP"><span class="iconfont-archer">&#xe606;</span>CSP</span>
    
        <span class="sidebar-tag-name" data-tags="XSS"><span class="iconfont-archer">&#xe606;</span>XSS</span>
    
        <span class="sidebar-tag-name" data-tags="PA"><span class="iconfont-archer">&#xe606;</span>PA</span>
    
        <span class="sidebar-tag-name" data-tags="SELinux"><span class="iconfont-archer">&#xe606;</span>SELinux</span>
    
        <span class="sidebar-tag-name" data-tags="源码分析"><span class="iconfont-archer">&#xe606;</span>源码分析</span>
    
        <span class="sidebar-tag-name" data-tags="求职"><span class="iconfont-archer">&#xe606;</span>求职</span>
    
        <span class="sidebar-tag-name" data-tags="ios"><span class="iconfont-archer">&#xe606;</span>ios</span>
    
        <span class="sidebar-tag-name" data-tags="安全机制"><span class="iconfont-archer">&#xe606;</span>安全机制</span>
    
        <span class="sidebar-tag-name" data-tags="娱乐"><span class="iconfont-archer">&#xe606;</span>娱乐</span>
    
        <span class="sidebar-tag-name" data-tags="翻译"><span class="iconfont-archer">&#xe606;</span>翻译</span>
    
        <span class="sidebar-tag-name" data-tags="人生"><span class="iconfont-archer">&#xe606;</span>人生</span>
    
        <span class="sidebar-tag-name" data-tags="性能"><span class="iconfont-archer">&#xe606;</span>性能</span>
    
        <span class="sidebar-tag-name" data-tags="Linux"><span class="iconfont-archer">&#xe606;</span>Linux</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br>
    1、请确保node版本大于6.2<br>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="技术"><span class="iconfont-archer">&#xe60a;</span>技术</span>
    
        <span class="sidebar-category-name" data-categories="杂谈"><span class="iconfont-archer">&#xe60a;</span>杂谈</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "hurricane618"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


